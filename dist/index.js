'use strict';

var zustand = require('zustand');
var middleware = require('zustand/middleware');
var encoding = require('@cosmjs/encoding');
var cosmiframe = require('@dao-dao/cosmiframe');
var snapper = require('@cosmsnap/snapper');
var amino = require('@cosmjs/amino');
var nn = require('long');
var signClient = require('@walletconnect/sign-client');
var utils = require('@walletconnect/utils');
var reactQuery = require('@tanstack/react-query');
var react = require('react');
var cosmwasmStargate = require('@cosmjs/cosmwasm-stargate');
var stargate = require('@cosmjs/stargate');
var tendermintRpc = require('@cosmjs/tendermint-rpc');
var shallow = require('zustand/shallow');
var jsxRuntime = require('react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var nn__default = /*#__PURE__*/_interopDefault(nn);

var Ut=Object.defineProperty,Ft=Object.defineProperties;var qt=Object.getOwnPropertyDescriptors;var se=Object.getOwnPropertySymbols;var Ge=Object.prototype.hasOwnProperty,ze=Object.prototype.propertyIsEnumerable;var qe=(e,t,n)=>t in e?Ut(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,M=(e,t)=>{for(var n in t||(t={}))Ge.call(t,n)&&qe(e,n,t[n]);if(se)for(var n of se(t))ze.call(t,n)&&qe(e,n,t[n]);return e},F=(e,t)=>Ft(e,qt(t));var Qe=(e,t)=>{var n={};for(var o in e)Ge.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(e!=null&&se)for(var o of se(e))t.indexOf(o)<0&&ze.call(e,o)&&(n[o]=e[o]);return n};var c=(e,t,n)=>new Promise((o,r)=>{var i=l=>{try{a(n.next(l));}catch(m){r(m);}},s=l=>{try{a(n.throw(l));}catch(m){r(m);}},a=l=>l.done?o(l.value):Promise.resolve(l.value).then(i,s);a((n=n.apply(e,t)).next());});var V="graz-reconnect-session";var je=(b=>(b.KEPLR="keplr",b.LEAP="leap",b.VECTIS="vectis",b.COSMOSTATION="cosmostation",b.WALLETCONNECT="walletconnect",b.WC_KEPLR_MOBILE="wc_keplr_mobile",b.WC_LEAP_MOBILE="wc_leap_mobile",b.WC_COSMOSTATION_MOBILE="wc_cosmostation_mobile",b.WC_CLOT_MOBILE="wc_clot_mobile",b.METAMASK_SNAP_LEAP="metamask_snap_leap",b.METAMASK_SNAP_COSMOS="metamask_snap_cosmos",b.STATION="station",b.XDEFI="xdefi",b.CAPSULE="capsule",b.COSMIFRAME="cosmiframe",b.COMPASS="compass",b.INITIA="initia",b))(je||{}),$e=["keplr","leap","vectis","cosmostation","walletconnect","wc_keplr_mobile","wc_leap_mobile","wc_cosmostation_mobile","wc_clot_mobile","metamask_snap_leap","station","xdefi","capsule","metamask_snap_cosmos","cosmiframe","compass","initia"];var zt={iframeOptions:null,recentChainIds:null,chains:null,chainsConfig:null,capsuleConfig:null,capsuleState:null,multiChainFetchConcurrency:3,walletType:"keplr",walletConnect:{options:null,web3Modal:null},walletDefaultOptions:null,_notFoundFn:()=>null,_onReconnectFailed:()=>null,_reconnect:!1,_reconnectConnector:null},te={accounts:null,activeChainIds:null,status:"disconnected",wcSignClients:new Map,capsuleClient:null},Qt={name:"graz-session",version:2,partialize:e=>({accounts:e.accounts,activeChainIds:e.activeChainIds}),storage:middleware.createJSONStorage(()=>sessionStorage)},jt={name:"graz-internal",partialize:e=>({recentChainIds:e.recentChainIds,_reconnect:e._reconnect,_reconnectConnector:e._reconnectConnector,walletType:e.walletType}),version:2},g=zustand.create(middleware.subscribeWithSelector(middleware.persist(()=>te,Qt))),u=zustand.create(middleware.subscribeWithSelector(middleware.persist(()=>zt,jt)));var ae=()=>{var d,S;if(!((d=u.getState().capsuleConfig)!=null&&d.apiKey)||!((S=u.getState().capsuleConfig)!=null&&S.env))throw new Error("Capsule configuration is not set");let e=()=>c(void 0,null,function*(){var h,O;let p=(yield import('@leapwallet/cosmos-social-login-capsule-provider')).CapsuleProvider,f=new p({apiKey:(h=u.getState().capsuleConfig)==null?void 0:h.apiKey,env:(O=u.getState().capsuleConfig)==null?void 0:O.env});return g.setState({capsuleClient:f}),f});return {init:e,enable:p=>c(void 0,null,function*(){let f=typeof p=="string"?[p]:p,h=g.getState().capsuleClient;h||(h=yield e()),u.setState({capsuleState:{showModal:!0,chainId:f}});}),onAfterLoginSuccessful:()=>c(void 0,null,function*(){var b;let p=g.getState().capsuleClient,{chains:f}=u.getState();if(!p)throw new Error("Capsule client is not initialized");if(!f)throw new Error("Chains are not set");yield p.enable();let h=(b=u.getState().capsuleState)==null?void 0:b.chainId;if(!h)throw new Error("Chain ids are not set");let O=Object.fromEntries(yield Promise.all(h.map(y=>c(void 0,null,function*(){let I=yield p.getAccount(y);return [y,{address:encoding.fromBech32(I.address).data,bech32Address:I.address,algo:I.algo,name:I.username||"",pubKey:I.pubkey,isKeystone:!1,isNanoLedger:!1}]}))));g.setState(y=>({accounts:M(M({},y.accounts||{}),O)})),u.setState(y=>({recentChainIds:[...y.recentChainIds||[],...h].filter((I,x,W)=>W.indexOf(I)===x)})),g.setState(y=>({activeChainIds:[...y.activeChainIds||[],...h].filter((I,x,W)=>W.indexOf(I)===x)})),u.setState({walletType:"capsule",_reconnect:!1,_reconnectConnector:"capsule"}),g.setState({status:"connected"}),typeof window!="undefined"&&window.sessionStorage.setItem(V,"Active"),u.setState({capsuleState:null});}),getKey:p=>c(void 0,null,function*(){let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");let h=yield f.getAccount(p);return {address:encoding.fromBech32(h.address).data,bech32Address:h.address,algo:h.algo,name:h.username||"",pubKey:h.pubkey,isKeystone:!1,isNanoLedger:!1}}),getOfflineSignerAuto:p=>c(void 0,null,function*(){let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");return f.getOfflineSignerDirect(p)}),getOfflineSignerDirect:p=>{let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");return f.getOfflineSignerDirect(p)},signDirect:(...p)=>c(void 0,null,function*(){let[f,h,O]=p,b=g.getState().capsuleClient;if(!b)throw new Error("Capsule client is not initialized");return b.signDirect(f,h,{bodyBytes:O.bodyBytes,authInfoBytes:O.authInfoBytes,chainId:O.chainId,accountNumber:O.accountNumber})}),signAmino:(...p)=>c(void 0,null,function*(){let[f,h,O,b]=p,y=g.getState().capsuleClient;if(!y)throw new Error("Capsule client is not initialized");return y.signAmino(f,h,O,b)}),experimentalSuggestChain:(...p)=>c(void 0,null,function*(){yield Promise.reject(new Error("Capsule does not support experimentalSuggestChain"));}),getOfflineSigner:p=>{let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");return f.getOfflineSigner(p)},getOfflineSignerAmino:p=>{let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");return f.getOfflineSignerAmino(p)}}};var ce=()=>{if(typeof window.compass!="undefined"){let e=window.compass;return Object.assign(e,{subscription:r=>{let i=()=>{K(),r();};return window.addEventListener("leap_keystorechange",i),()=>{window.removeEventListener("leap_keystorechange",i);}},setDefaultOptions:r=>{e.defaultOptions=r;}})}throw u.getState()._notFoundFn(),new Error("window.leap is not defined")};var le=()=>{let e=u.getState();if(!e.iframeOptions)throw e._notFoundFn(),new Error("no iframe options set");if(!cosmiframe.isInIframe())throw e._notFoundFn(),new Error("not in iframe");if(!e.iframeOptions.allowedIframeParentOrigins.length)throw e._notFoundFn(),new Error("no iframe allowed origins");let t=new cosmiframe.Cosmiframe(e.iframeOptions.allowedIframeParentOrigins).getKeplrClient();return {enable:t.enable.bind(t),getKey:t.getKey.bind(t),getOfflineSigner:t.getOfflineSigner.bind(t),getOfflineSignerAuto:t.getOfflineSignerAuto.bind(t),getOfflineSignerOnlyAmino:t.getOfflineSignerOnlyAmino.bind(t),experimentalSuggestChain:t.experimentalSuggestChain.bind(t),signDirect:t.signDirect.bind(t),signAmino:t.signAmino.bind(t)}};var et={},tt=()=>{let e=window.ethereum,t=window.cosmos;if(e)return {init:()=>c(void 0,null,function*(){var w;let i=yield e.request({method:"web3_clientVersion"});if(!i.includes("MetaMask"))throw new Error("Metamask is not installed");if(typeof window.okxwallet!="undefined"&&window.okxwallet.isOkxWallet)throw new Error("You have OKX Wallet installed. Please disable and reload the page to use Metamask Snap.");let a=(w=i.split("MetaMask/v")[1])==null?void 0:w.split(".")[0];if(!(Number(a)>=11))throw new Error("Metamask Snap is not supported in this version");return (yield snapper.isSnapInstalled())||(yield snapper.installSnap()),window.cosmos=new snapper.CosmosSnap,t=window.cosmos,!0}),enable:i=>c(void 0,null,function*(){(yield snapper.isSnapInstalled())||(yield snapper.installSnap());}),getOfflineSigner:i=>t.getOfflineSigner(i),experimentalSuggestChain:i=>c(void 0,null,function*(){yield t.experimentalSuggestChain(i);}),signAmino:(i,s,a)=>c(void 0,null,function*(){return t.signAmino(i,s,a)}),getKey:i=>c(void 0,null,function*(){return typeof et[i]!="undefined"?et[i]:t.getKey(i)}),getOfflineSignerAuto:i=>c(void 0,null,function*(){return (yield t.getKey(i)).isNanoLedger?t.getOfflineSignerOnlyAmino(i):t.getOfflineSigner(i)}),getOfflineSignerOnlyAmino:i=>t.getOfflineSignerOnlyAmino(i),signDirect:(i,s,a)=>c(void 0,null,function*(){return t.signDirect(i,s,a)}),signArbitrary:(i,s,a)=>c(void 0,null,function*(){return t.signArbitrary(i,s,a)}),disable:i=>c(void 0,null,function*(){i&&(yield t.deleteChain(i));})};throw u.getState()._notFoundFn(),new Error("window.ethereum is not defined")};var ue=()=>{var e;if(typeof((e=window.cosmostation)==null?void 0:e.providers.keplr)!="undefined"){let t=window.cosmostation.providers.keplr;return Object.assign(t,{subscription:i=>{let s=()=>{K(),i();};return window.addEventListener("cosmostation_keystorechange",s),()=>{window.removeEventListener("cosmostation_keystorechange",s);}},setDefaultOptions:i=>{t.defaultOptions=i;}})}throw u.getState()._notFoundFn(),new Error("window.cosmostation.providers.keplr is not defined")};var en=e=>{let{bodyBytes:t,authInfoBytes:n,chainId:o,accountNumber:r}=e;if(!t||!n||!o||!r)throw new Error("Invalid sign doc");return {bodyBytes:t,authInfoBytes:n,chainId:o,accountNumber:r}},tn=e=>`${e.slice(0,6)}...${e.slice(-6)}`,it=()=>{if(typeof window.initia!="undefined"){let e=window.initia;return {enable:()=>c(void 0,null,function*(){yield e.getAddress();}),getKey:d=>c(void 0,null,function*(){let S=e.getOfflineSigner(d),[p]=yield S.getAccounts();if(!p)throw new Error("Wallet connection failed");let f=(()=>{switch(p.algo){case"secp256k1":return amino.rawSecp256k1PubkeyToRawAddress(p.pubkey);case"ed25519":return amino.rawEd25519PubkeyToRawAddress(p.pubkey);default:throw new Error("sr25519 public key algorithm is not supported")}})();return {name:tn(p.address),algo:p.algo,pubKey:p.pubkey,bech32Address:p.address,address:f,isNanoLedger:!1,isKeystone:!1}}),getOfflineSigner:d=>{let S=e.getOfflineSigner(d),p=e.getOfflineSignerOnlyAmino(d);return {getAccounts:S.getAccounts.bind(S),signDirect:S.signDirect.bind(S),signAmino:p.signAmino.bind(p)}},getOfflineSignerAuto:d=>Promise.resolve(e.getOfflineSigner(d)),getOfflineSignerOnlyAmino:d=>e.getOfflineSignerOnlyAmino(d),experimentalSuggestChain:d=>e.requestAddInitiaLayer({chain_id:d.chainId,chain_name:d.chainName,bech32_prefix:"init",bech32_config:d.bech32Config,slip44:d.bip44.coinType,logo_URIs:{png:d.chainSymbolImageUrl},fees:{fee_tokens:d.feeCurrencies.map(S=>{var p,f,h;return {denom:S.coinDenom,amount:S.coinMinimalDenom,low_gas_price:(p=S.gasPriceStep)==null?void 0:p.low,average_gas_price:(f=S.gasPriceStep)==null?void 0:f.average,high_gas_price:(h=S.gasPriceStep)==null?void 0:h.high}})},apis:{rpc:[{address:d.rpc}],rest:[{address:d.rest}]}}),signDirect:(...d)=>{let[S,p,f]=d;return e.getOfflineSigner(S).signDirect(p,en(f))},signAmino:(...d)=>{let[S,p,f]=d;return e.getOfflineSignerOnlyAmino(S).signAmino(p,f)},signArbitrary:(d,S,p)=>c(void 0,null,function*(){let O=(yield e.getOfflineSigner(d).getAccounts()).find(I=>I.address===S);if(!O)throw new Error(`Wallet not connected to account ${S}`);let b=(()=>{switch(O.algo){case"secp256k1":return amino.encodeSecp256k1Pubkey(O.pubkey);case"ed25519":return amino.encodeEd25519Pubkey(O.pubkey);default:throw new Error("sr25519 public key algorithm is not supported")}})();return {signature:yield e.signArbitrary(p),pub_key:{type:O.algo==="secp256k1"?amino.pubkeyType.secp256k1:amino.pubkeyType.ed25519,value:b.value}}}),subscription:d=>{let S=()=>{K(),d();};return window.addEventListener("initia_keystorechange",S),()=>{window.removeEventListener("initia_keystorechange",S);}}}}throw u.getState()._notFoundFn(),new Error("window.initia is not defined")};var pe=()=>{if(typeof window.keplr!="undefined"){let e=window.keplr;return Object.assign(e,{subscription:r=>{let i=()=>{K(),r();};return window.addEventListener("keplr_keystorechange",i),()=>{window.removeEventListener("keplr_keystorechange",i);}},setDefaultOptions:r=>{e.defaultOptions=r;}})}throw u.getState()._notFoundFn(),new Error("window.keplr is not defined")};var me=()=>{if(typeof window.leap!="undefined"){let e=window.leap;return Object.assign(e,{subscription:r=>{let i=()=>{K(),r();};return window.addEventListener("leap_keystorechange",i),()=>{window.removeEventListener("leap_keystorechange",i);}},setDefaultOptions:r=>{e.defaultOptions=r;}})}throw u.getState()._notFoundFn(),new Error("window.leap is not defined")};var de={},ot=e=>{let t=window.ethereum;if(t&&e){let n=()=>c(void 0,null,function*(){return yield t.request({method:"wallet_getSnaps"})}),o=y=>c(void 0,null,function*(){try{let I=yield n();return Object.values(I).find(x=>x.id===e.id&&(!y||x.version===y))}catch(I){return}}),r=()=>c(void 0,null,function*(){yield t.request({method:"wallet_requestSnaps",params:{[e.id]:e.params||{}}});}),i=()=>c(void 0,null,function*(){var D;let y=yield t.request({method:"web3_clientVersion"});if(!y.includes("MetaMask"))throw new Error("Metamask is not installed");if(typeof window.okxwallet!="undefined"&&window.okxwallet.isOkxWallet)throw new Error("You have OKX Wallet installed. Please disable and reload the page to use Metamask Snap.");let x=(D=y.split("MetaMask/v")[1])==null?void 0:D.split(".")[0];if(!(Number(x)>=11))throw new Error("Metamask Snap is not supported in this version");return (yield o())||(yield r()),!0}),s=y=>c(void 0,null,function*(){(yield o())||(yield r());}),a=(y,I,x)=>c(void 0,null,function*(){let W=yield t.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"signDirect",params:{chainId:y,signerAddress:I,signDoc:x}}}}),_=x.accountNumber,D=new nn__default.default(_.low,_.high,_.unsigned);return {signature:W.signature,signed:F(M({},W.signed),{accountNumber:D.toString(),authInfoBytes:new Uint8Array(Object.values(W.signed.authInfoBytes)),bodyBytes:new Uint8Array(Object.values(W.signed.bodyBytes))})}}),l=(y,I,x)=>c(void 0,null,function*(){return yield t.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"signAmino",params:{chainId:y,signerAddress:I,signDoc:x}}}})}),m=y=>c(void 0,null,function*(){if(typeof de[y]!="undefined")return de[y];let I=yield t.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"getKey",params:{chainId:y}}}});if(!I)throw new Error("No response from Metamask");return I.pubKey=Uint8Array.from(Object.values(I.pubkey)),delete I.pubkey,de[y]=I,de[y]}),w=y=>c(void 0,null,function*(){let I=yield m(y);return {address:I.bech32Address,algo:I.algo,pubkey:I.pubKey}}),d=(...y)=>c(void 0,null,function*(){let[I,x,W,_]=y;return yield l(I,x,W)}),S=(...y)=>c(void 0,null,function*(){let[I,x,W]=y;return yield a(I,x,W)}),f=y=>({getAccounts:()=>c(void 0,null,function*(){return [yield w(y)]}),signAmino:(I,x)=>d(y,I,x)});return {enable:s,experimentalSuggestChain:(...y)=>c(void 0,null,function*(){yield i(),yield t.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"suggestChain",params:{chainInfo:y[0]}}}});}),getKey:m,getOfflineSigner:y=>({getAccounts:()=>c(void 0,null,function*(){return [yield w(y)]}),signDirect:(I,x)=>S(y,I,x),signAmino:(I,x)=>d(y,I,x)}),getOfflineSignerAuto:y=>c(void 0,null,function*(){return f(y)}),getOfflineSignerOnlyAmino:f,init:i,signAmino:d,signDirect:S}}throw u.getState()._notFoundFn(),new Error("window.ethereum is not defined")};var rt=()=>ot({id:"npm:@leapwallet/metamask-cosmos-snap"});var fe=()=>{if(typeof window.station!="undefined"){let e=window.station.keplr;return {subscription:i=>{let s=()=>{K(),i();};return window.addEventListener("station_wallet_change",s),()=>{window.removeEventListener("station_wallet_change",s);}},getKey:i=>c(void 0,null,function*(){let s=yield e.getKey(i);return M({isKeystone:!1},s)}),getOfflineSigner:i=>{try{let s=e.getOfflineSignerOnlyAmino(i);return Object.assign(s,{signDirect:(m,w)=>{throw new Error("signDirect not supported by Station")}})}catch(s){throw console.error(s),s}},experimentalSuggestChain:i=>c(void 0,null,function*(){try{let s=Object.assign(i,{chainSymbolImageUrl:i.chainSymbolImageUrl||"",stakeCurrency:{coinDecimals:i.stakeCurrency.coinDecimals,coinDenom:i.stakeCurrency.coinDenom,coinImageUrl:i.stakeCurrency.coinImageUrl||"",coinMinimalDenom:i.stakeCurrency.coinMinimalDenom},currencies:i.currencies.map(a=>({coinDecimals:a.coinDecimals,coinDenom:a.coinDenom,coinImageUrl:a.coinImageUrl||"",coinMinimalDenom:a.coinMinimalDenom})),feeCurrencies:i.feeCurrencies.map(a=>{var l,m,w;return {coinDecimals:a.coinDecimals,coinDenom:a.coinDenom,coinImageUrl:a.coinImageUrl||"",coinMinimalDenom:a.coinMinimalDenom,gasPriceStep:{average:((l=a.gasPriceStep)==null?void 0:l.average)||0,high:((m=a.gasPriceStep)==null?void 0:m.high)||0,low:((w=a.gasPriceStep)==null?void 0:w.low)||0}}})});yield e.experimentalSuggestChain(s);}catch(s){throw console.error(s),s}}),enable:i=>e.enable(i),disable:i=>e.disable(i),getOfflineSignerAuto:i=>e.getOfflineSignerAuto(i),getOfflineSignerOnlyAmino:i=>e.getOfflineSignerOnlyAmino(i),signDirect:()=>e.signDirect(),signAmino:(i,s,a,l)=>e.signAmino(i,s,a)}}throw u.getState()._notFoundFn(),new Error("window.station is not defined")};var ge=()=>{if(typeof window.vectis!="undefined"){let e=window.vectis.cosmos;return {enable:a=>e.enable(a),getOfflineSigner:a=>e.getOfflineSigner(a),getOfflineSignerAuto:a=>e.getOfflineSignerAuto(a),getKey:a=>c(void 0,null,function*(){let l=yield e.getKey(a);return {address:encoding.fromBech32(l.address).data,algo:l.algo,bech32Address:l.address,name:l.name,pubKey:l.pubKey,isKeystone:!1,isNanoLedger:l.isNanoLedger}}),subscription:a=>{let l=()=>{K(),a();};return window.addEventListener("vectis_accountChanged",l),()=>{window.removeEventListener("vectis_accountChanged",l);}},getOfflineSignerOnlyAmino:(...a)=>e.getOfflineSignerAmino(...a),experimentalSuggestChain:(...a)=>c(void 0,null,function*(){let[l]=a,m=F(M({},l),{rpcUrl:l.rpc,restUrl:l.rest,prettyName:l.chainName.replace(" ",""),bech32Prefix:l.bech32Config.bech32PrefixAccAddr});return e.suggestChains([m])}),signDirect:(...a)=>c(void 0,null,function*(){var w;let{1:l,2:m}=a;return e.signDirect(l,{bodyBytes:m.bodyBytes||Uint8Array.from([]),authInfoBytes:m.authInfoBytes||Uint8Array.from([]),accountNumber:nn__default.default.fromString(((w=m.accountNumber)==null?void 0:w.toString())||"",!1),chainId:m.chainId||""})}),signAmino:(...a)=>c(void 0,null,function*(){let{1:l,2:m}=a;return e.signAmino(l,m)})}}throw u.getState()._notFoundFn(),new Error("window.vectis is not defined")};var z=()=>typeof window!="undefined"?!!(window.matchMedia("(pointer:coarse)").matches||/Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)):!1,st=()=>z()&&navigator.userAgent.toLowerCase().includes("android"),at=()=>z()&&(navigator.userAgent.toLowerCase().includes("iphone")||navigator.userAgent.toLowerCase().includes("ipad"));var Me=(e,t,n=new Error("Promise timed out"))=>{let o=new Promise((r,i)=>{setTimeout(()=>{i(n);},t);});return Promise.race([e,o])};var Q=e=>{var D,X,ne;if(!((ne=(X=(D=u.getState().walletConnect)==null?void 0:D.options)==null?void 0:X.projectId)!=null&&ne.trim()))throw new Error("walletConnect.options.projectId is not defined");let t=(e==null?void 0:e.walletType)||"walletconnect",n=(e==null?void 0:e.encoding)||"base64",o=C=>{if(!e)return;let{appUrl:A,formatNativeUrl:E}=e;if(z()){if(st())if(!C)window.open(A.mobile.android,"_self","noreferrer noopener");else {let v=E(A.mobile.android,C,"android");window.open(v,"_self","noreferrer noopener");}if(at())if(!C)window.open(A.mobile.ios,"_self","noreferrer noopener");else {let v=E(A.mobile.ios,C,"ios");window.open(v,"_self","noreferrer noopener");}}},r=()=>{let{wcSignClients:C}=g.getState();if(!C.get(t))throw new Error("walletConnect.signClient is not defined");C.delete(t),g.setState({wcSignClients:C}),u.setState({_reconnect:!1,_reconnectConnector:null,recentChainIds:null});},i=C=>c(void 0,null,function*(){let{wcSignClients:A}=g.getState(),E=A.get(t);if(!E)throw new Error("walletConnect.signClient is not defined");if(!C)throw new Error("No wallet connect session");yield E.disconnect({topic:C,reason:utils.getSdkError("USER_DISCONNECTED")}),yield l(E);}),s=C=>{try{let{wcSignClients:A}=g.getState(),E=A.get(t);if(!E)throw new Error("walletConnect.signClient is not defined");let v=E.session.getAll().at(-1);if(!v)return;if(!(v.expiry*1e3>Date.now()+1e3))throw i(v.topic),new Error("invalid session");try{let k=E.find({requiredNamespaces:{cosmos:{methods:["cosmos_getAccounts","cosmos_signAmino","cosmos_signDirect"],chains:C.map(L=>`cosmos:${L}`),events:["chainChanged","accountsChanged"]}}});if(!k.length)throw new Error("no session");return k.at(-1)}catch(k){if(!k.message.toLowerCase().includes("no matching key"))throw k}return v}catch(A){if(!A.message.toLowerCase().includes("no matching key"))throw A}},a=C=>{try{return s(C)}catch(A){return}},l=C=>c(void 0,null,function*(){try{let A=C.core.pairing.pairings.getAll({active:!1});if(!A.length)return;yield Promise.all(A.map(E=>c(void 0,null,function*(){yield C.core.pairing.pairings.delete(E.topic,{code:7001,message:"clear pairing"});})));}catch(A){if(!A.message.toLowerCase().includes("no matching key"))throw A}}),m=()=>c(void 0,null,function*(){let{walletConnect:C}=u.getState();if(!(C!=null&&C.options))throw new Error("walletConnect.options is not defined");let{wcSignClients:A}=g.getState(),E=A.get(t);if(E)return E;let v=yield signClient.SignClient.init(C.options);return A.set(t,v),g.setState({wcSignClients:A}),v}),w=C=>{let{wcSignClients:A}=g.getState(),E=A.get(t);if(!E)return ()=>{};let v=P=>{let k=g.getState().accounts;if(P.params.event.name==="accountsChanged"&&k&&!Object.values(k).map(L=>L.bech32Address).includes(P.params.event.data[0])){let L=P.params.chainId.split(":")[1];L&&d([L]);}else C();};return E.events.on("session_delete",r),E.events.on("session_expire",r),E.events.on("session_event",v),()=>{E.events.off("session_delete",r),E.events.off("session_expire",r),E.events.off("session_event",v);}},d=C=>c(void 0,null,function*(){var oe;let A=typeof C=="string"?[C]:C,{wcSignClients:E}=g.getState(),v=E.get(t);if(!v)throw new Error("enable walletConnect.signClient is not defined");let{walletConnect:P,chains:k}=u.getState();if(!((oe=P==null?void 0:P.options)!=null&&oe.projectId))throw new Error("walletConnect.options.projectId is not defined");let{Web3Modal:L}=yield import('@web3modal/standalone'),$=new L(M({projectId:P.options.projectId,walletConnectVersion:2,enableExplorer:!1,explorerRecommendedWalletIds:"NONE"},P.web3Modal)),J=a(A);if(!J){let{uri:U,approval:Z}=yield Me(v.connect({requiredNamespaces:{cosmos:{methods:["cosmos_getAccounts","cosmos_signAmino","cosmos_signDirect"],chains:A.map(j=>`cosmos:${j}`),events:["chainChanged","accountsChanged"]}}}),15e3,new Error("Connection timeout"));if(!U)throw new Error("No wallet connect uri");e?o(U):yield $.openModal({uri:U});let Bt=j=>c(void 0,null,function*(){return j.aborted?Promise.reject(new Error("User closed wallet connect")):new Promise((be,ee)=>{Z().then(Be=>{let Le=Be.sessionProperties;if(!Le)return ee(new Error("No session properties"));let Te=JSON.parse(String(Le.keys));if(Te.length===0)return ee(new Error("No accounts"));let Ue=Te[0];if(!Ue)return ee(new Error("No accounts"));let Fe={};return A.forEach(re=>{Fe[re]=F(M({},Ue),{bech32Address:encoding.toBech32(k.find(Lt=>Lt.chainId===re).bech32Config.bech32PrefixAccAddr,encoding.fromBech32(Te[0].bech32Address).data)});}),g.setState(re=>({accounts:M(M({},re.accounts||{}),Fe)})),be(Be)}).catch(ee),j.addEventListener("abort",()=>{ee(new Error("User closed wallet connect"));},{once:!0});})});try{let j=new AbortController,be=j.signal;$.subscribeModal(ee=>{ee.open||j.abort();}),yield Bt(be);}catch(j){if($.closeModal(),j instanceof Error&&!j.message.toLowerCase().includes("no matching key"))return Promise.reject(j)}return e||$.closeModal(),Promise.resolve()}try{yield Me((()=>c(void 0,null,function*(){let U=Object.fromEntries(yield Promise.all(A.map(Z=>c(void 0,null,function*(){return [Z,yield p(Z)]}))));g.setState({accounts:U});}))(),15e3,new Error("Connection timeout"));}catch(U){if(i(J.topic),!U.message.toLowerCase().includes("no matching key"))throw U}}),S=C=>c(void 0,null,function*(){var k;let{wcSignClients:A}=g.getState(),E=A.get(t);if(!E)throw new Error("walletConnect.signClient is not defined");let v=(k=s([C]))==null?void 0:k.topic;if(!v)throw new Error("No wallet connect session");let P=yield E.request({topic:v,chainId:`cosmos:${C}`,request:{method:"cosmos_getAccounts",params:{}}});if(!P[0])throw new Error("No wallet connect account");return {address:P[0].address,algo:P[0].algo,pubkey:new Uint8Array(Buffer.from(P[0].pubkey,n))}}),p=C=>c(void 0,null,function*(){let A=s([C]);if(!(A!=null&&A.topic))throw new Error("No wallet connect session");let E=A.sessionProperties&&JSON.parse(String(A.sessionProperties.keys))[0];if(!E)throw new Error("No wallet connect key");return E}),f=(...C)=>c(void 0,null,function*(){var U,Z;let[A,E,v]=C,{accounts:P,wcSignClients:k}=g.getState(),L=k.get(t);if(!L)throw new Error("walletConnect.signClient is not defined");if(!P)throw new Error("account is not defined");let $=(U=s([A]))==null?void 0:U.topic;if(!$)throw new Error("No wallet connect session");if(!v.bodyBytes)throw new Error("No bodyBytes");if(!v.authInfoBytes)throw new Error("No authInfoBytes");let J={topic:$,chainId:`cosmos:${A}`,request:{method:"cosmos_signDirect",params:{signerAddress:E,signDoc:F(M({},v),{bodyBytes:Buffer.from(v.bodyBytes).toString(n),authInfoBytes:Buffer.from(v.authInfoBytes).toString(n),accountNumber:(Z=v.accountNumber)==null?void 0:Z.toString()})}}};return o(),yield L.request(J)}),h=(...C)=>c(void 0,null,function*(){let[A,E,v]=C,{signature:P,signed:k}=yield f(A,E,v);return {signed:{chainId:k.chainId,accountNumber:nn__default.default.fromString(k.accountNumber,!1),authInfoBytes:new Uint8Array(Buffer.from(k.authInfoBytes,n)),bodyBytes:new Uint8Array(Buffer.from(k.bodyBytes,n))},signature:P}}),O=(...C)=>c(void 0,null,function*(){var U;let[A,E,v,P]=C,{wcSignClients:k}=g.getState(),L=k.get(t),{accounts:$}=g.getState();if(!L)throw new Error("walletConnect.signClient is not defined");if(!$)throw new Error("account is not defined");let J=(U=s([A]))==null?void 0:U.topic;if(!J)throw new Error("No wallet connect session");return o(),yield L.request({topic:J,chainId:`cosmos:${A}`,request:{method:"cosmos_signDirect",params:{signerAddress:E,signDoc:v}}})}),b=(...C)=>c(void 0,null,function*(){let[A,E,v,P]=C;return yield O(A,E,v)}),y=C=>({getAccounts:()=>c(void 0,null,function*(){return [yield S(C)]}),signDirect:(A,E)=>h(C,A,E)}),I=C=>({getAccounts:()=>c(void 0,null,function*(){return [yield S(C)]}),signAmino:(A,E)=>b(C,A,E)});return {enable:d,disable:C=>c(void 0,null,function*(){var v;let{wcSignClients:A}=g.getState(),E=A.get(t);if(C===void 0){let P=E==null?void 0:E.session.getAll();P!==void 0&&(yield Promise.all(P.map(k=>i(k.topic))));}else typeof C=="string"?yield i((v=s([C]))==null?void 0:v.topic):yield Promise.all(C.map(P=>{var k;return i((k=s([P]))==null?void 0:k.topic)}));(E==null?void 0:E.session.getAll().length)===0&&r();}),experimentalSuggestChain:(...C)=>c(void 0,null,function*(){yield Promise.reject(new Error("WalletConnect does not support experimentalSuggestChain"));}),getKey:p,getOfflineSigner:C=>({getAccounts:()=>c(void 0,null,function*(){return [yield S(C)]}),signDirect:(A,E)=>h(C,A,E),signAmino:(A,E)=>b(C,A,E)}),getOfflineSignerAuto:C=>c(void 0,null,function*(){return (yield p(C)).isNanoLedger?I(C):y(C)}),getOfflineSignerOnlyAmino:I,signAmino:b,signDirect:h,subscription:w,init:m}};var ct=()=>{var t,n,o;if(!((o=(n=(t=u.getState().walletConnect)==null?void 0:t.options)==null?void 0:n.projectId)!=null&&o.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!z())throw new Error("WalletConnect Clot mobile is only supported in mobile");let e={encoding:"base64",appUrl:{mobile:{android:"clot://",ios:"clot://"}},walletType:"wc_clot_mobile",formatNativeUrl:(r,i,s)=>{let a=r.replaceAll("/","").replaceAll(":",""),l=encodeURIComponent(i);switch(s){case"ios":return `${a}://wcV2?${l}`;default:return `${a}://wc?uri=${l}`}}};return Q(e)};var lt=()=>{var t,n,o;if(!((o=(n=(t=u.getState().walletConnect)==null?void 0:t.options)==null?void 0:n.projectId)!=null&&o.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!z())throw new Error("WalletConnect Cosmostation mobile is only supported in mobile");let e={encoding:"hex",appUrl:{mobile:{ios:"cosmostation://",android:"cosmostation://"}},walletType:"wc_cosmostation_mobile",formatNativeUrl:(r,i,s)=>`${r.replaceAll("/","").replaceAll(":","")}://wc?${i}`};return Q(e)};var ut=()=>{var t,n,o;if(!((o=(n=(t=u.getState().walletConnect)==null?void 0:t.options)==null?void 0:n.projectId)!=null&&o.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!z())throw new Error("WalletConnect Keplr mobile is only supported in mobile");let e={encoding:"base64",appUrl:{mobile:{ios:"keplrwallet://",android:"intent://"}},walletType:"wc_keplr_mobile",formatNativeUrl:(r,i,s)=>{let a=r.replaceAll("/","").replaceAll(":",""),l=encodeURIComponent(i);switch(s){case"ios":return `${a}://wcV2?${l}`;case"android":return `${a}://wcV2?${l}#Intent;package=com.chainapsis.keplr;scheme=keplrwallet;end;`;default:return `${a}://wc?uri=${l}`}}};return Q(e)};var pt=()=>{var t,n,o;if(!((o=(n=(t=u.getState().walletConnect)==null?void 0:t.options)==null?void 0:n.projectId)!=null&&o.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!z())throw new Error("WalletConnect Leap mobile is only supported in mobile");let e={encoding:"base64",appUrl:{mobile:{ios:"leapcosmos://",android:"intent://"}},walletType:"wc_leap_mobile",formatNativeUrl:(r,i,s)=>{let a=r.replaceAll("/","").replaceAll(":",""),l=encodeURIComponent(i);switch(s){case"ios":return `${a}://wcV2?${l}`;case"android":return `${a}://wcV2?${l}#Intent;package=io.leapwallet.cosmos;scheme=leapwallet;end;`;default:return `${a}://wc?uri=${l}`}}};return Q(e)};var ye=()=>{var e;if(typeof((e=window.xfi)==null?void 0:e.keplr)!="undefined"){let t=window.xfi.keplr;return Object.assign(t,{subscription:r=>{let i=()=>{K(),r();};return window.addEventListener("keplr_keystorechange",i),()=>{window.removeEventListener("keplr_keystorechange",i);}}})}throw u.getState()._notFoundFn(),new Error("window.xfi.keplr is not defined")};var N=(e=u.getState().walletType)=>{try{return R(e),!0}catch(t){return !1}},K=()=>{window.sessionStorage.removeItem(V),g.setState(te);},R=(e=u.getState().walletType)=>{var o;let t=(()=>{switch(e){case"keplr":return pe();case"leap":return me();case"cosmostation":return ue();case"vectis":return ge();case"walletconnect":return Q();case"wc_keplr_mobile":return ut();case"wc_leap_mobile":return pt();case"wc_cosmostation_mobile":return lt();case"wc_clot_mobile":return ct();case"metamask_snap_leap":return rt();case"metamask_snap_cosmos":return tt();case"station":return fe();case"xdefi":return ye();case"capsule":return ae();case"cosmiframe":return le();case"compass":return ce();case"initia":return it();default:throw new Error("Unknown wallet type")}})(),n=u.getState().walletDefaultOptions;return n&&((o=t.setDefaultOptions)==null||o.call(t,n)),t},Vo=()=>Object.fromEntries($e.map(e=>[e,N(e)])),xe=e=>e==="capsule",mt=e=>e==="walletconnect"||e==="wc_keplr_mobile"||e==="wc_leap_mobile"||e==="wc_cosmostation_mobile";var H=e=>c(void 0,null,function*(){var t;try{let{recentChainIds:n,chains:o,walletType:r}=u.getState(),i=(e==null?void 0:e.walletType)||r;if(!N(i))throw new Error(`${i} is not available`);let a=R(i),l=typeof(e==null?void 0:e.chainId)=="string"?[e.chainId]:(e==null?void 0:e.chainId)||n;if(!l)throw new Error("No last known connected chain, connect action requires chain ids");let m=o==null?void 0:o.map(p=>p.chainId);l.forEach(p=>{if(!(m!=null&&m.includes(p)))throw new Error(`Chain ${p} is not provided in GrazProvider`)}),g.setState(p=>{let f=u.getState()._reconnect||!!u.getState()._reconnectConnector||!!l;return p.activeChainIds&&l.filter(O=>{var b;return !((b=p.activeChainIds)!=null&&b.includes(O))}).length>0?{status:"connecting"}:f?{status:"reconnecting"}:{status:"connecting"}});let{accounts:w}=g.getState();if(yield (t=a.init)==null?void 0:t.call(a),xe(i)&&g.getState().capsuleClient&&Object.values(g.getState().accounts||[]).length>0){let p=l.map(O=>o.find(b=>b.chainId===O)),f=g.getState().accounts;g.setState({status:"connecting"});let h=Object.fromEntries(yield Promise.all(l.map(O=>c(void 0,null,function*(){return [O,yield a.getKey(O)]}))));return g.setState(O=>({accounts:M(M({},O.accounts||{}),h)})),u.setState(O=>({recentChainIds:[...O.recentChainIds||[],...l].filter((b,y,I)=>I.indexOf(b)===y)})),g.setState(O=>({activeChainIds:[...O.activeChainIds||[],...l].filter((b,y,I)=>I.indexOf(b)===y)})),g.setState({status:"connected"}),{accounts:f,walletType:i,chains:p}}if(yield a.enable(l),xe(i)){let p=l.map(h=>o.find(O=>O.chainId===h)),f=g.getState().accounts;return g.setState({status:"connecting"}),{accounts:f,walletType:i,chains:p}}if(!mt(i)){let p=Object.fromEntries(yield Promise.all(l.map(f=>c(void 0,null,function*(){return [f,yield a.getKey(f)]}))));g.setState(f=>({accounts:M(M({},f.accounts||{}),p)}));}u.setState(p=>({recentChainIds:[...p.recentChainIds||[],...l].filter((f,h,O)=>O.indexOf(f)===h)})),g.setState(p=>({activeChainIds:[...p.activeChainIds||[],...l].filter((f,h,O)=>O.indexOf(f)===h)})),u.setState({walletType:i,_reconnect:!!(e!=null&&e.autoReconnect),_reconnectConnector:i}),g.setState({status:"connected"}),typeof window!="undefined"&&window.sessionStorage.setItem(V,"Active");let d=l.map(p=>o.find(f=>f.chainId===p));return {accounts:g.getState().accounts,walletType:i,chains:d}}catch(n){throw console.error("connect ",n),g.getState().accounts===null&&g.setState({status:"disconnected"}),g.getState().accounts&&g.getState().activeChainIds&&g.setState({status:"connected"}),n}}),ie=e=>{typeof window!="undefined"&&window.sessionStorage.removeItem(V);let t=typeof(e==null?void 0:e.chainId)=="string"?[e.chainId]:e==null?void 0:e.chainId;if(t){let n=g.getState().accounts;t.forEach(r=>{n==null||delete n[r];}),Object.values(n||{}).length===0?(g.setState(te),u.setState({_reconnect:!1,_reconnectConnector:null,recentChainIds:null})):(g.setState(r=>{var i;return {activeChainIds:(i=r.activeChainIds)==null?void 0:i.filter(s=>!t.includes(s)),accounts:n}}),u.setState(r=>{var i;return {recentChainIds:(i=r.recentChainIds)==null?void 0:i.filter(s=>!t.includes(s))}}));}else g.setState(te),u.setState({_reconnect:!1,_reconnectConnector:null,recentChainIds:null});return Promise.resolve()},q=e=>c(void 0,null,function*(){var r;let{recentChainIds:t,_reconnectConnector:n,_reconnect:o}=u.getState();try{let i=N(n||void 0);if(t&&i&&n)return yield H({chainId:t,walletType:n,autoReconnect:o})}catch(i){(r=e==null?void 0:e.onError)==null||r.call(e,i),ie();}}),dt=e=>c(void 0,null,function*(){if(!(e!=null&&e.chainId))throw new Error("chainId is required");let{walletType:t}=u.getState(),n=e.walletType||t;if(!N(n))throw new Error(`${n} is not available`);let r=R(n),i=r.getOfflineSigner(e.chainId),s=r.getOfflineSignerOnlyAmino(e.chainId),a=yield r.getOfflineSignerAuto(e.chainId);return {offlineSigner:i,offlineSignerAmino:s,offlineSignerAuto:a}});var ve=()=>{u.setState({recentChainIds:null});},sr=()=>u.getState().recentChainIds,ar=()=>{var n;let{recentChainIds:e,chains:t}=u.getState();return (n=e==null?void 0:e.map(o=>t.find(r=>r.chainId===o)))!=null?n:null},cr=({chainId:e})=>{var t;return (t=u.getState().chains)==null?void 0:t.find(n=>n.chainId===e)},lr=({chainId:e})=>{var t;return (t=u.getState().chains)==null?void 0:t.filter(n=>e==null?void 0:e.includes(n.chainId))},ke=n=>c(void 0,[n],function*({chainInfo:e,walletType:t}){let o=R(t);return t==="capsule"?yield H({chainId:e.chainId,walletType:t}):yield o.experimentalSuggestChain(e),e}),ft=e=>c(void 0,null,function*(){var o;let t=u.getState().walletType;return yield ke({chainInfo:e.chainInfo,walletType:(o=e.walletType)!=null?o:t}),yield H({chainId:e.chainInfo.chainId,walletType:e.walletType,autoReconnect:e.autoReconnect})});var gt=e=>(u.setState(t=>({iframeOptions:e.iframeOptions||t.iframeOptions,walletConnect:e.walletConnect||t.walletConnect,walletType:e.defaultWallet||t.walletType,capsuleConfig:e.capsuleConfig||t.capsuleConfig,walletDefaultOptions:e.walletDefaultOptions||t.walletDefaultOptions,chains:e.chains,chainsConfig:e.chainsConfig||t.chainsConfig,multiChainFetchConcurrency:e.multiChainFetchConcurrency||t.multiChainFetchConcurrency,_notFoundFn:e.onNotFound||t._notFoundFn,_onReconnectFailed:e.onReconnectFailed||t._onReconnectFailed,_reconnect:e.autoReconnect===void 0?!0:e.autoReconnect||t._reconnect})),e);var yt=s=>c(void 0,[s],function*({signingClient:e,senderAddress:t,recipientAddress:n,amount:o,fee:r,memo:i}){if(!e)throw new Error("No connected account detected");if(!t)throw new Error("senderAddress is not defined");return e.sendTokens(t,n,o,r,i)}),St=w=>c(void 0,[w],function*({signingClient:e,senderAddress:t,recipientAddress:n,transferAmount:o,sourcePort:r,sourceChannel:i,timeoutHeight:s,timeoutTimestamp:a,fee:l,memo:m}){if(!e)throw new Error("Stargate signing client is not ready");if(!t)throw new Error("senderAddress is not defined");return e.sendIbcTokens(t,n,o,r,i,s,a,l,m)}),Ct=a=>c(void 0,[a],function*({signingClient:e,senderAddress:t,msg:n,fee:o,options:r,label:i,codeId:s}){if(!e)throw new Error("CosmWasm signing client is not ready");return e.instantiate(t,s,n,i,o,r)}),ht=a=>c(void 0,[a],function*({signingClient:e,senderAddress:t,msg:n,fee:o,contractAddress:r,funds:i,memo:s}){if(!e)throw new Error("CosmWasm signing client is not ready");return e.execute(t,r,n,o,s,i)}),wt=(e,t,n)=>c(void 0,null,function*(){if(!n)throw new Error("CosmWasm client is not ready");return yield n.queryContractSmart(e,t)}),At=(e,t,n)=>{if(!n)throw new Error("CosmWasm client is not ready");let o=new TextEncoder().encode(t);return n.queryContractRaw(e,o)};var hr=e=>e,wr=e=>e;var Se=e=>e?Object.keys(e).length===0:!0;var Pe=class extends Error{constructor(t){super(),this.name="AbortError",this.message=t;}},It=e=>globalThis.DOMException===void 0?new Pe(e):new DOMException(e),Ot=e=>{let t=e.reason===void 0?It("This operation was aborted."):e.reason;return t instanceof Error?t:It(t)};function We(i,s){return c(this,arguments,function*(e,t,{concurrency:n=Number.POSITIVE_INFINITY,stopOnError:o=!0,signal:r}={}){return new Promise((a,l)=>{if(e[Symbol.iterator]===void 0&&e[Symbol.asyncIterator]===void 0)throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof e})`);if(typeof t!="function")throw new TypeError("Mapper function is required");if(!((Number.isSafeInteger(n)||n===Number.POSITIVE_INFINITY)&&n>=1))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${n}\` (${typeof n})`);let m=[],w=[],d=new Map,S=!1,p=!1,f=!1,h=0,O=0,b=e[Symbol.iterator]===void 0?e[Symbol.asyncIterator]():e[Symbol.iterator](),y=x=>{S=!0,p=!0,l(x);};r&&(r.aborted&&y(Ot(r)),r.addEventListener("abort",()=>{y(Ot(r));}));let I=()=>c(this,null,function*(){if(p)return;let x=yield b.next(),W=O;if(O++,x.done){if(f=!0,h===0&&!p){if(!o&&w.length>0){y(new AggregateError(w));return}if(p=!0,d.size===0){a(m);return}let _=[];for(let[D,X]of m.entries())d.get(D)!==Et&&_.push(X);a(_);}return}h++,c(this,null,function*(){try{let _=yield x.value;if(p)return;let D=yield t(_,W);D===Et&&d.set(W,D),m[W]=D,h--,yield I();}catch(_){if(o)y(_);else {w.push(_),h--;try{yield I();}catch(D){y(D);}}}});});c(this,null,function*(){for(let x=0;x<n;x++){try{yield I();}catch(W){y(W);break}if(f||S)break}});})})}var Et=Symbol("skip");var B=({chainId:e,multiChain:t})=>{let n=u(r=>r.chains);if(!n)throw new Error("No chains found in GrazProvider");let o=typeof e=="string"?[e]:e;switch(!0){case(!!t&&!!o):return o.map(r=>n.find(i=>i.chainId===r)).filter(Boolean);case(!t&&!!o):return [o.map(r=>n.find(i=>i.chainId===r)).filter(Boolean)[0]];case(!!t&&!o):return n;default:return [n[0]]}},G=(e,t,n)=>c(void 0,null,function*(){let o=u.getState().multiChainFetchConcurrency;if(e){let i=yield We(t,n,{concurrency:o});return Object.fromEntries(i.map((s,a)=>[t[a].chainId,s]))}return yield n(t[0])}),bt=(e,t,n)=>{if(e){let r=t.map(n);return Object.fromEntries(r.map((i,s)=>[t[s].chainId,i]))}return n(t[0])};var _e=e=>{let t=B({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=react.useMemo(()=>["USE_STARGATE_CLIENT",t],[t]);return reactQuery.useQuery({queryKey:n,queryFn:r=>c(void 0,[r],function*({queryKey:[,o]}){if(o.length<1)throw new Error("No chains found");return yield G(!!(e!=null&&e.multiChain),o,s=>c(void 0,null,function*(){var w;let a=(w=u.getState().chainsConfig)==null?void 0:w[s.chainId],l={url:s.rpc,headers:M({},(a==null?void 0:a.rpcHeaders)||{})};return yield stargate.StargateClient.connect(l)}))}),enabled:!!t&&t.length>0&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})},Ke=e=>{let t=B({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=react.useMemo(()=>["USE_COSMWASM_CLIENT",t],[t]);return reactQuery.useQuery({queryKey:n,queryFn:r=>c(void 0,[r],function*({queryKey:[,o]}){if(o.length<1)throw new Error("No chains found");return yield G(!!(e!=null&&e.multiChain),o,s=>c(void 0,null,function*(){var w;let a=(w=u.getState().chainsConfig)==null?void 0:w[s.chainId],l={url:s.rpc,headers:M({},(a==null?void 0:a.rpcHeaders)||{})};return yield cosmwasmStargate.CosmWasmClient.connect(l)}))}),enabled:!!t&&t.length>0&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})},Ce=({type:e,chainId:t,multiChain:n,enabled:o})=>{let r=B({chainId:t,multiChain:n}),i=react.useMemo(()=>["USE_TENDERMINT_CLIENT",e,r],[e,r]);return reactQuery.useQuery({queryKey:i,queryFn:l=>c(void 0,[l],function*({queryKey:[,s,a]}){if(a.length<1)throw new Error("No chains found");return yield G(!!n,a,w=>c(void 0,null,function*(){var h;let d=(h=u.getState().chainsConfig)==null?void 0:h[w.chainId],S={url:w.rpc,headers:M({},(d==null?void 0:d.rpcHeaders)||{})};return yield (s==="tm37"?tendermintRpc.Tendermint37Client:tendermintRpc.Tendermint34Client).connect(S)}))}),enabled:!!r&&r.length>0&&(o!==void 0?!!o:!0),refetchOnWindowFocus:!1})};var $r=()=>u(e=>({walletType:e.walletType,isCosmostation:e.walletType==="cosmostation",isCosmostationMobile:e.walletType==="wc_cosmostation_mobile",isKeplr:e.walletType==="keplr",isKeplrMobile:e.walletType==="wc_keplr_mobile",isLeap:e.walletType==="leap",isLeapMobile:e.walletType==="wc_leap_mobile",isVectis:e.walletType==="vectis",isWalletConnect:e.walletType==="walletconnect",isMetamaskSnapLeap:e.walletType==="metamask_snap_leap",isStation:e.walletType==="station",isCapsule:e.walletType==="capsule",isCosmiframe:e.walletType==="cosmiframe"}),shallow.shallow),he=e=>{let n=["USE_CHECK_WALLET",u(r=>e||r.walletType)];return reactQuery.useQuery({queryKey:n,queryFn:({queryKey:[,r]})=>N(r)})};var Y=e=>{let t=u(a=>a.walletType),n=g(a=>a.activeChainIds),o=B({chainId:e!=null&&e.chainId?e.chainId:n||void 0,multiChain:e==null?void 0:e.multiChain}),r=g(a=>a.accounts),i=g(a=>a.status);return react.useEffect(()=>g.subscribe(a=>a.status,(a,l)=>{var m,w,d;if(a==="connected"){let{accounts:S,activeChainIds:p}=g.getState(),{chains:f}=u.getState(),{walletType:h}=u.getState();if(!S||!p||!f)return (m=e==null?void 0:e.onDisconnect)==null?void 0:m.call(e);(w=e==null?void 0:e.onConnect)==null||w.call(e,{accounts:S,chains:p.map(O=>f.find(b=>b.chainId===O)),walletType:h,isReconnect:l==="reconnecting"});}a==="disconnected"&&((d=e==null?void 0:e.onDisconnect)==null||d.call(e));}),[e]),{data:react.useMemo(()=>r?bt(!!(e!=null&&e.multiChain),o,a=>r[a.chainId]):void 0,[r,o,e==null?void 0:e.multiChain]),isConnected:i==="connected",isConnecting:i==="connecting",isDisconnected:i==="disconnected",isReconnecting:i==="reconnecting",isLoading:i==="connecting"||i==="reconnecting",walletType:i==="connected"?t:void 0,reconnect:q,status:i}},Cn=e=>{let t=B({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),{data:n}=Y(),o=(e==null?void 0:e.bech32Address)||(n==null?void 0:n.bech32Address),{data:r}=_e({chainId:t.map(s=>s.chainId),multiChain:!0,enabled:((e==null?void 0:e.enabled)===void 0?!0:e.enabled)&&!!o}),i=react.useMemo(()=>["USE_ALL_BALANCES",r,t,o,e==null?void 0:e.chainId],[o,e==null?void 0:e.chainId,t,r]);return reactQuery.useQuery({queryKey:i,queryFn:m=>c(void 0,[m],function*({queryKey:[,s,a,l]}){if(!l)throw new Error("address is not defined");return yield G(!!(e!=null&&e.multiChain),a,d=>c(void 0,null,function*(){let S=s==null?void 0:s[d.chainId];if(!S)throw new Error(`Client is not ready ${d.chainId}`);return yield S.getAllBalances(encoding.toBech32(d.bech32Config.bech32PrefixAccAddr,encoding.fromBech32(l).data))}))}),enabled:!!o&&!!t&&t.length>0&&!Se(r)&&((e==null?void 0:e.enabled)===void 0?!0:e.enabled),refetchOnMount:!1,refetchOnReconnect:!0,refetchOnWindowFocus:!1})},ss=e=>{let t=B({chainId:e.chainId}),{data:n}=Y({chainId:e.chainId}),o=e.bech32Address||(n==null?void 0:n.bech32Address),{data:r,refetch:i}=Cn({chainId:t.map(l=>l.chainId),bech32Address:o,enabled:!!o&&(e.enabled===void 0?!0:e.enabled)}),s=["USE_BALANCE",e.denom,r,t,o,e.chainId],a=reactQuery.useQuery({queryKey:s,queryFn:({queryKey:[,l,m]})=>m==null?void 0:m.find(w=>w.denom===l),enabled:!!e.denom&&!!r&&!!(r!=null&&r.length)&&(e.enabled===void 0?!0:e.enabled)});return F(M({},a),{refetch:l=>c(void 0,null,function*(){return yield i(),a.refetch(l)})})},as=({onError:e,onLoading:t,onSuccess:n}={})=>{let r=reactQuery.useMutation({mutationKey:["USE_CONNECT",e,t,n],mutationFn:H,onError:(s,a)=>e==null?void 0:e(s,a),onMutate:t,onSuccess:s=>Promise.resolve(n==null?void 0:n(s))}),{data:i}=he();return {connect:s=>r.mutate(s),connectAsync:s=>r.mutateAsync(s),error:r.error,isLoading:r.isPending,isSuccess:r.isSuccess,isSupported:!!i,status:r.status}},cs=({onError:e,onLoading:t,onSuccess:n}={})=>{let r=reactQuery.useMutation({mutationKey:["USE_DISCONNECT",e,t,n],mutationFn:ie,onError:i=>Promise.resolve(e==null?void 0:e(i,void 0)),onMutate:t,onSuccess:()=>Promise.resolve(n==null?void 0:n(void 0))});return {disconnect:i=>r.mutate(i),disconnectAsync:i=>r.mutateAsync(i),error:r.error,isLoading:r.isPending,isSuccess:r.isSuccess,status:r.status}},ls=e=>{let t=B({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=u(r=>r.walletType),o=react.useMemo(()=>["USE_OFFLINE_SIGNERS",t,n],[t,n]);return reactQuery.useQuery({queryKey:o,queryFn:s=>c(void 0,[s],function*({queryKey:[,r,i]}){if(r.length<1)throw new Error("No chain found");if(!N(i))throw new Error(`${i} is not available`);return yield G(!!(e!=null&&e.multiChain),r,m=>c(void 0,null,function*(){return yield dt({chainId:m.chainId,walletType:i})}))}),enabled:!!t&&t.length>0&&!!n,refetchOnWindowFocus:!1})},us=e=>{let t=B({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),{data:n}=Y(),{data:o}=_e({chainId:t.map(s=>s.chainId),multiChain:!0}),r=(e==null?void 0:e.bech32Address)||(n==null?void 0:n.bech32Address),i=react.useMemo(()=>["USE_BALANCE_STAKED",o,t,r],[t,r,o]);return reactQuery.useQuery({queryKey:i,queryFn:m=>c(void 0,[m],function*({queryKey:[,s,a,l]}){if(!l)throw new Error("address is not defined");return yield G(!!(e!=null&&e.multiChain),a,d=>c(void 0,null,function*(){var p;if(!s)throw new Error("Client is not ready");return yield (p=s[d.chainId])==null?void 0:p.getBalanceStaked(encoding.toBech32(d.bech32Config.bech32PrefixAccAddr,encoding.fromBech32(l).data))}))}),enabled:!!r&&!!t&&t.length>0&&!!o,refetchOnMount:!1,refetchOnReconnect:!0,refetchOnWindowFocus:!1})};var Ss=()=>{let e=u(o=>o.capsuleState),t=g(o=>o.capsuleClient),n=ae();return {setModalState:o=>{u.setState(r=>{var i;return {capsuleState:{showModal:o,chainId:(i=r.capsuleState)==null?void 0:i.chainId}}});},modalState:!!(e!=null&&e.showModal),client:t,onAfterLoginSuccessful:n.onAfterLoginSuccessful,onLoginFailure:()=>{ie();}}};var Es=()=>g(e=>e.activeChainIds),hn=()=>{var e;return (e=g(t=>t.activeChainIds))==null?void 0:e.map(t=>{var o;let n=(o=u.getState().chains)==null?void 0:o.find(r=>r.chainId===t);if(n)return n}).filter(Boolean)},bs=({chainId:e})=>{var t;return (t=u().chains)==null?void 0:t.find(n=>n.chainId===e)},Ts=({chainId:e})=>{var t;return (t=u().chains)==null?void 0:t.filter(n=>e==null?void 0:e.includes(n.chainId))},Ms=({denom:e})=>{let t=hn();return reactQuery.useQuery({queryKey:["USE_ACTIVE_CHAIN_CURRENCY",e],queryFn:({queryKey:[,r]})=>{var i;return (i=t==null?void 0:t.find(s=>s.currencies.find(a=>a.coinMinimalDenom===r)))==null?void 0:i.currencies.find(s=>s)}})},xs=e=>{var r;let t=(r=e.status)!=null?r:"BOND_STATUS_BONDED",n=["USE_ACTIVE_CHAIN_VALIDATORS",e.queryClient,t];return reactQuery.useQuery({queryKey:n,queryFn:a=>c(void 0,[a],function*({queryKey:[,i,s]}){if(!i)throw new Error("Query client is not defined");return yield i.staking.validators(s)}),enabled:typeof e.queryClient!="undefined"})},vs=()=>({data:u(t=>t.recentChainIds),clear:ve}),ks=()=>{var t;return {data:(t=u(n=>n.recentChainIds))==null?void 0:t.map(n=>{var r;let o=(r=u.getState().chains)==null?void 0:r.find(i=>i.chainId===n);if(o)return o}).filter(Boolean),clear:ve}},Ps=({onError:e,onLoading:t,onSuccess:n}={})=>{let r=reactQuery.useMutation({mutationKey:["USE_SUGGEST_CHAIN",e,t,n],mutationFn:ke,onError:(i,s)=>Promise.resolve(e==null?void 0:e(i,s.chainInfo)),onMutate:i=>t==null?void 0:t(i.chainInfo),onSuccess:i=>Promise.resolve(n==null?void 0:n(i))});return {error:r.error,isLoading:r.isPending,isSuccess:r.isSuccess,suggest:r.mutate,suggestAsync:r.mutateAsync,status:r.status}},Ws=({onError:e,onLoading:t,onSuccess:n}={})=>{let r=reactQuery.useMutation({mutationKey:["USE_SUGGEST_CHAIN_AND_CONNECT",e,t,n],mutationFn:ft,onError:(s,a)=>Promise.resolve(e==null?void 0:e(s,a)),onMutate:s=>t==null?void 0:t(s),onSuccess:s=>Promise.resolve(n==null?void 0:n(s))}),{data:i}=he();return {error:r.error,isLoading:r.isPending,isSuccess:r.isSuccess,isSupported:!!i,status:r.status,suggestAndConnect:r.mutate,suggestAndConnectAsync:r.mutateAsync}};var Us=({onError:e,onLoading:t,onSuccess:n}={})=>{let{data:o}=Y(),r=o==null?void 0:o.bech32Address,i=reactQuery.useMutation({mutationKey:["USE_SEND_TOKENS",e,t,n,r],mutationFn:s=>yt(M({senderAddress:r},s)),onError:(s,a)=>Promise.resolve(e==null?void 0:e(s,a)),onMutate:t,onSuccess:s=>Promise.resolve(n==null?void 0:n(s))});return {error:i.error,isLoading:i.isPending,isSuccess:i.isSuccess,sendTokens:i.mutate,sendTokensAsync:i.mutateAsync,status:i.status}},Fs=({onError:e,onLoading:t,onSuccess:n}={})=>{let{data:o}=Y(),r=o==null?void 0:o.bech32Address,i=reactQuery.useMutation({mutationKey:["USE_SEND_IBC_TOKENS",e,t,n,r],mutationFn:s=>St(M({senderAddress:r},s)),onError:(s,a)=>Promise.resolve(e==null?void 0:e(s,a)),onMutate:t,onSuccess:s=>Promise.resolve(n==null?void 0:n(s))});return {error:i.error,isLoading:i.isPending,isSuccess:i.isSuccess,sendIbcTokens:i.mutate,sendIbcTokensAsync:i.mutateAsync,status:i.status}},qs=({codeId:e,onError:t,onLoading:n,onSuccess:o})=>{let{data:r}=Y(),i=r==null?void 0:r.bech32Address,a=reactQuery.useMutation({mutationKey:["USE_INSTANTIATE_CONTRACT",t,n,o,e,i],mutationFn:l=>{var w;if(!i)throw new Error("senderAddress is undefined");let m=F(M({},l),{fee:(w=l.fee)!=null?w:"auto",senderAddress:i,codeId:e});return Ct(m)},onError:(l,m)=>Promise.resolve(t==null?void 0:t(l,m)),onMutate:n,onSuccess:l=>Promise.resolve(o==null?void 0:o(l))});return {error:a.error,isLoading:a.isPending,isSuccess:a.isSuccess,instantiateContract:a.mutate,instantiateContractAsync:a.mutateAsync,status:a.status}},Gs=({contractAddress:e,onError:t,onLoading:n,onSuccess:o})=>{let{data:r}=Y(),i=r==null?void 0:r.bech32Address,a=reactQuery.useMutation({mutationKey:["USE_EXECUTE_CONTRACT",t,n,o,e,i],mutationFn:l=>{var w,d,S;if(!i)throw new Error("senderAddress is undefined");let m=F(M({},l),{fee:(w=l.fee)!=null?w:"auto",senderAddress:i,contractAddress:e,memo:(d=l.memo)!=null?d:"",funds:(S=l.funds)!=null?S:[]});return ht(m)},onError:(l,m)=>Promise.resolve(t==null?void 0:t(l,m)),onMutate:n,onSuccess:l=>Promise.resolve(o==null?void 0:o(l))});return {error:a.error,isLoading:a.isPending,isSuccess:a.isSuccess,executeContract:a.mutate,executeContractAsync:a.mutateAsync,status:a.status}},zs=e=>{let{data:t}=Ke();return reactQuery.useQuery({queryKey:["USE_QUERY_SMART",e==null?void 0:e.address,e==null?void 0:e.queryMsg,t],queryFn:({queryKey:[,o]})=>{if(!(e!=null&&e.address)||!e.queryMsg)throw new Error("address or queryMsg undefined");return wt(e.address,e.queryMsg,t)},enabled:!!(e!=null&&e.address)&&!!(e!=null&&e.queryMsg)&&!!t})},Qs=e=>{let{data:t}=Ke(),n=["USE_QUERY_RAW",e==null?void 0:e.key,e==null?void 0:e.address,t];return reactQuery.useQuery({queryKey:n,queryFn:({queryKey:[,r]})=>{if(!(e!=null&&e.address)||!e.key)throw new Error("address or key undefined");return At(e.address,e.key,t)},enabled:!!(e!=null&&e.address)&&!!(e!=null&&e.key)&&!!t})};function oa(e){let t=B({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=u(i=>i.walletType),o=g(i=>i.activeChainIds),r=react.useMemo(()=>["USE_STARGATE_SIGNING_CLIENT",t,n,e,o],[o,e,t,n]);return reactQuery.useQuery({queryKey:r,queryFn:a=>c(this,[a],function*({queryKey:[,i,s]}){if(i.length<1)throw new Error("No chains found");return yield G(!!(e!=null&&e.multiChain),i,m=>c(this,null,function*(){var h,O;if(!(o!=null&&o.includes(m.chainId)))return null;if(!N(s))throw new Error(`${s} is not available`);let d=yield (()=>c(this,null,function*(){switch(e==null?void 0:e.offlineSigner){case"offlineSigner":return R(s).getOfflineSigner(m.chainId);case"offlineSignerAuto":return R(s).getOfflineSignerAuto(m.chainId);case"offlineSignerOnlyAmino":return R(s).getOfflineSignerOnlyAmino(m.chainId);default:return R(s).getOfflineSignerAuto(m.chainId)}}))(),S=(h=u.getState().chainsConfig)==null?void 0:h[m.chainId],p={url:m.rpc,headers:M({},(S==null?void 0:S.rpcHeaders)||{})};return (e==null?void 0:e.multiChain)===!0&&e.opts,yield stargate.SigningStargateClient.connectWithSigner(p,d,e!=null&&e.multiChain?(O=e.opts)==null?void 0:O[m.chainId]:e==null?void 0:e.opts)}))}),enabled:!!t&&t.length>0&&!!n&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}function ra(e){let t=B({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=u(i=>i.walletType),o=g(i=>i.activeChainIds),r=react.useMemo(()=>["USE_COSMWASM_SIGNING_CLIENT",t,n,e,o],[o,e,t,n]);return reactQuery.useQuery({queryKey:r,queryFn:a=>c(this,[a],function*({queryKey:[,i,s]}){if(i.length<1)throw new Error("No chains found");return yield G(!!(e!=null&&e.multiChain),i,m=>c(this,null,function*(){var O,b;if(!(o!=null&&o.includes(m.chainId)))return null;if(!N(s))throw new Error(`${s} is not available`);let d=yield (()=>c(this,null,function*(){switch(e==null?void 0:e.offlineSigner){case"offlineSigner":return R(s).getOfflineSigner(m.chainId);case"offlineSignerAuto":return R(s).getOfflineSignerAuto(m.chainId);case"offlineSignerOnlyAmino":return R(s).getOfflineSignerOnlyAmino(m.chainId);default:return R(s).getOfflineSignerAuto(m.chainId)}}))(),S=(O=u.getState().chainsConfig)==null?void 0:O[m.chainId],p={url:m.rpc,headers:M({},(S==null?void 0:S.rpcHeaders)||{})},f=S!=null&&S.gas?stargate.GasPrice.fromString(`${S.gas.price}${S.gas.denom}`):void 0;return yield cosmwasmStargate.SigningCosmWasmClient.connectWithSigner(p,d,M({gasPrice:f},e!=null&&e.multiChain?(b=e.opts)==null?void 0:b[m.chainId]:(e==null?void 0:e.opts)||{}))}))}),enabled:!!t&&t.length>0&&!!n&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}function sa(e){let t=B({chainId:e.chainId,multiChain:e.multiChain}),n=u(s=>s.walletType),o=g(s=>s.activeChainIds),r=react.useMemo(()=>["USE_STARGATE_TM_SIGNING_CLIENT",t,n,e,o],[o,e,t,n]),{data:i}=Ce({type:e.type,chainId:e.chainId,multiChain:e.multiChain});return reactQuery.useQuery({queryKey:r,queryFn:l=>c(this,[l],function*({queryKey:[,s,a]}){if(s.length<1)throw new Error("No chains found");return yield G(!!e.multiChain,s,w=>c(this,null,function*(){var h;if(!(o!=null&&o.includes(w.chainId)))return null;if(!N(a))throw new Error(`${a} is not available`);if(!i)throw new Error("No tendermint client found");let S=yield (()=>c(this,null,function*(){switch(e.offlineSigner){case"offlineSigner":return R(a).getOfflineSigner(w.chainId);case"offlineSignerAuto":return R(a).getOfflineSignerAuto(w.chainId);case"offlineSignerOnlyAmino":return R(a).getOfflineSignerOnlyAmino(w.chainId);default:return R(a).getOfflineSignerAuto(w.chainId)}}))(),p=e.multiChain?i[w.chainId]:i;return yield stargate.SigningStargateClient.createWithSigner(p,S,e.multiChain?(h=e.opts)==null?void 0:h[w.chainId]:e.opts)}))}),enabled:!!t&&t.length>0&&!!n&&!!i&&(e.enabled!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}function aa(e){let t=B({chainId:e.chainId,multiChain:e.multiChain}),n=u(a=>a.walletType),o=g(a=>a.activeChainIds),r=react.useMemo(()=>["USE_COSMWASM_TM_SIGNING_CLIENT",t,n,e,o],[o,e,t,n]),{data:i}=Ce({type:e.type,chainId:e.chainId,multiChain:!1,enabled:!e.multiChain}),{data:s}=Ce({type:e.type,chainId:e.chainId,multiChain:!0,enabled:!!e.multiChain});return reactQuery.useQuery({queryKey:r,queryFn:m=>c(this,[m],function*({queryKey:[,a,l]}){if(a.length<1)throw new Error("No chains found");return yield G(!!e.multiChain,a,d=>c(this,null,function*(){var y,I;if(!(o!=null&&o.includes(d.chainId)))return null;if(!N(l))throw new Error(`${l} is not available`);let p=yield (()=>c(this,null,function*(){switch(e.offlineSigner){case"offlineSigner":return R(l).getOfflineSigner(d.chainId);case"offlineSignerAuto":return R(l).getOfflineSignerAuto(d.chainId);case"offlineSignerOnlyAmino":return R(l).getOfflineSignerOnlyAmino(d.chainId);default:return R(l).getOfflineSignerAuto(d.chainId)}}))(),f=(y=u.getState().chainsConfig)==null?void 0:y[d.chainId],h=f!=null&&f.gas?stargate.GasPrice.fromString(`${f.gas.price}${f.gas.denom}`):void 0,O=e.multiChain?s==null?void 0:s[d.chainId]:i;if(!O)throw new Error("No tendermint client found");return yield cosmwasmStargate.SigningCosmWasmClient.createWithSigner(O,p,M({gasPrice:h},e.multiChain?(I=e.opts)==null?void 0:I[d.chainId]:e.opts||{}))}))}),enabled:!!t&&t.length>0&&!!n&&(!!i||!Se(s))&&(e.enabled!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}var _t=({children:e})=>{let[t,n]=react.useState(!1);return react.useEffect(()=>{n(!0);},[]),jsxRuntime.jsx(jsxRuntime.Fragment,{children:t?e:null})};var bn=()=>{let e=typeof window!="undefined"&&window.sessionStorage.getItem(V)==="Active",{_reconnect:t,_onReconnectFailed:n,_reconnectConnector:o,iframeOptions:r,chains:i}=u(),{activeChainIds:s,wcSignClients:a}=g(),l=N(o||void 0);return react.useEffect(()=>{if(!r||r.autoConnect===!1||!r.allowedIframeParentOrigins.length||!i)return;new cosmiframe.Cosmiframe(r.allowedIframeParentOrigins).isReady().then(w=>{if(w)return H({chainId:i.map(d=>d.chainId),walletType:"cosmiframe"})});},[r]),react.useEffect(()=>{if(o){if(!l)return;e&&s?q({onError:n}):!e&&t&&q({onError:n});}},[l]),react.useEffect(()=>{var m,w,d,S,p,f,h,O,b,y,I,x,W,_,D,X,ne,C;if(o){if(!l)return;o==="cosmostation"&&((w=(m=ue()).subscription)==null||w.call(m,()=>{q({onError:n});})),o==="keplr"&&((S=(d=pe()).subscription)==null||S.call(d,()=>{q({onError:n});})),o==="leap"&&((f=(p=me()).subscription)==null||f.call(p,()=>{q({onError:n});})),o==="compass"&&((O=(h=ce()).subscription)==null||O.call(h,()=>{q({onError:n});})),o==="vectis"&&((y=(b=ge()).subscription)==null||y.call(b,()=>{q({onError:n});})),o==="walletconnect"&&a.has("walletconnect")&&((x=(I=Q()).subscription)==null||x.call(I,()=>{q({onError:n});})),o==="station"&&((_=(W=fe()).subscription)==null||_.call(W,()=>{q({onError:n});})),o==="xdefi"&&((X=(D=ye()).subscription)==null||X.call(D,()=>{q({onError:n});})),o==="cosmiframe"&&((C=(ne=le()).subscription)==null||C.call(ne,()=>{q({onError:n});}));}},[o,a,l]),null},Kt=()=>(bn(),null);var xn=new reactQuery.QueryClient({}),Ka=o=>{var r=o,{children:e,grazOptions:t}=r,n=Qe(r,["children","grazOptions"]);return gt(t),jsxRuntime.jsxs(reactQuery.QueryClientProvider,F(M({client:xn},n),{children:[e,jsxRuntime.jsx(_t,{children:jsxRuntime.jsx(Kt,{})})]}),"graz-provider")};

exports.GrazEvents = Kt;
exports.GrazProvider = Ka;
exports.WALLET_TYPES = $e;
exports.WalletType = je;
exports.checkWallet = N;
exports.clearRecentChain = ve;
exports.clearSession = K;
exports.configureGraz = gt;
exports.connect = H;
exports.defineChainInfo = wr;
exports.defineChains = hr;
exports.disconnect = ie;
exports.executeContract = ht;
exports.getAvailableWallets = Vo;
exports.getChainInfo = cr;
exports.getChainInfos = lr;
exports.getCosmostation = ue;
exports.getKeplr = pe;
exports.getLeap = me;
exports.getMetamaskSnapLeap = rt;
exports.getOfflineSigners = dt;
exports.getQueryRaw = At;
exports.getQuerySmart = wt;
exports.getRecentChainIds = sr;
exports.getRecentChains = ar;
exports.getVectis = ge;
exports.getWCCosmostation = lt;
exports.getWCKeplr = ut;
exports.getWCLeap = pt;
exports.getWallet = R;
exports.getWalletConnect = Q;
exports.instantiateContract = Ct;
exports.isCapsule = xe;
exports.isWalletConnect = mt;
exports.reconnect = q;
exports.sendIbcTokens = St;
exports.sendTokens = yt;
exports.suggestChain = ke;
exports.suggestChainAndConnect = ft;
exports.useAccount = Y;
exports.useActiveChainCurrency = Ms;
exports.useActiveChainIds = Es;
exports.useActiveChains = hn;
exports.useActiveWalletType = $r;
exports.useBalance = ss;
exports.useBalanceStaked = us;
exports.useBalances = Cn;
exports.useCapsule = Ss;
exports.useChainInfo = bs;
exports.useChainInfos = Ts;
exports.useCheckWallet = he;
exports.useConnect = as;
exports.useCosmWasmClient = Ke;
exports.useCosmWasmSigningClient = ra;
exports.useCosmWasmTmSigningClient = aa;
exports.useDisconnect = cs;
exports.useExecuteContract = Gs;
exports.useGrazEvents = bn;
exports.useInstantiateContract = qs;
exports.useOfflineSigners = ls;
exports.useQueryClientValidators = xs;
exports.useQueryRaw = Qs;
exports.useQuerySmart = zs;
exports.useRecentChainIds = vs;
exports.useRecentChains = ks;
exports.useSendIbcTokens = Fs;
exports.useSendTokens = Us;
exports.useStargateClient = _e;
exports.useStargateSigningClient = oa;
exports.useStargateTmSigningClient = sa;
exports.useSuggestChain = Ps;
exports.useSuggestChainAndConnect = Ws;
exports.useTendermintClient = Ce;
