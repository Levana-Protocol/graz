import { create } from 'zustand';
import { createJSONStorage, subscribeWithSelector, persist } from 'zustand/middleware';
import ki from 'crypto';
import { encodeEd25519Pubkey, encodeSecp256k1Pubkey, pubkeyType, rawEd25519PubkeyToRawAddress, rawSecp256k1PubkeyToRawAddress } from '@cosmjs/amino';
import { fromBech32, toBech32 } from '@cosmjs/encoding';
import { Cosmiframe, isInIframe } from '@dao-dao/cosmiframe';
import { isSnapInstalled, installSnap, CosmosSnap } from '@cosmsnap/snapper';
import bi from 'long';
import { SignClient } from '@walletconnect/sign-client';
import { getSdkError } from '@walletconnect/utils';
import { QueryClient, useQuery, useMutation, QueryClientProvider } from '@tanstack/react-query';
import { useMemo, useEffect, useState } from 'react';
import { CosmWasmClient, SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate';
import { StargateClient, SigningStargateClient, GasPrice } from '@cosmjs/stargate';
import { Tendermint37Client, Tendermint34Client } from '@cosmjs/tendermint-rpc';
import { shallow } from 'zustand/shallow';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';

var Jn=Object.create;var Lt=Object.defineProperty,Zn=Object.defineProperties,ei=Object.getOwnPropertyDescriptor,ti=Object.getOwnPropertyDescriptors,ni=Object.getOwnPropertyNames,Ct=Object.getOwnPropertySymbols,ii=Object.getPrototypeOf,Ut=Object.prototype.hasOwnProperty,en=Object.prototype.propertyIsEnumerable;var Zt=(e,n,o)=>n in e?Lt(e,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[n]=o,F=(e,n)=>{for(var o in n||(n={}))Ut.call(n,o)&&Zt(e,o,n[o]);if(Ct)for(var o of Ct(n))en.call(n,o)&&Zt(e,o,n[o]);return e},J=(e,n)=>Zn(e,ti(n));var tn=(e,n)=>{var o={};for(var r in e)Ut.call(e,r)&&n.indexOf(r)<0&&(o[r]=e[r]);if(e!=null&&Ct)for(var r of Ct(e))n.indexOf(r)<0&&en.call(e,r)&&(o[r]=e[r]);return o};var oi=(e,n)=>()=>(e&&(n=e(e=0)),n);var ri=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports);var si=(e,n,o,r)=>{if(n&&typeof n=="object"||typeof n=="function")for(let s of ni(n))!Ut.call(e,s)&&s!==o&&Lt(e,s,{get:()=>n[s],enumerable:!(r=ei(n,s))||r.enumerable});return e};var ai=(e,n,o)=>(o=e!=null?Jn(ii(e)):{},si(n||!e||!e.__esModule?Lt(o,"default",{value:e,enumerable:!0}):o,e));var u=(e,n,o)=>new Promise((r,s)=>{var i=l=>{try{c(o.next(l));}catch(f){s(f);}},a=l=>{try{c(o.throw(l));}catch(f){s(f);}},c=l=>l.done?r(l.value):Promise.resolve(l.value).then(i,a);c((o=o.apply(e,n)).next());});var h=oi(()=>{});var cn=ri((co,wt)=>{h();(function(){var e="input is invalid type",n="finalize already called",o=typeof window=="object",r=o?window:{};r.JS_SHA3_NO_WINDOW&&(o=!1);var s=!o&&typeof self=="object",i=!r.JS_SHA3_NO_NODE_JS&&typeof process=="object"&&process.versions&&process.versions.node;i?r=global:s&&(r=self);var a=!r.JS_SHA3_NO_COMMON_JS&&typeof wt=="object"&&wt.exports,c=typeof define=="function"&&define.amd,l=!r.JS_SHA3_NO_ARRAY_BUFFER&&typeof ArrayBuffer!="undefined",f="0123456789abcdef".split(""),T=[31,7936,2031616,520093696],C=[4,1024,262144,67108864],E=[1,256,65536,16777216],A=[6,1536,393216,100663296],y=[0,8,16,24],I=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],b=[224,256,384,512],D=[128,256],g=["hex","buffer","arrayBuffer","array","digest"],x={128:168,256:136};(r.JS_SHA3_NO_NODE_JS||!Array.isArray)&&(Array.isArray=function(t){return Object.prototype.toString.call(t)==="[object Array]"}),l&&(r.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)&&(ArrayBuffer.isView=function(t){return typeof t=="object"&&t.buffer&&t.buffer.constructor===ArrayBuffer});for(var R=function(t,d,m){return function(S){return new $(t,d,t).update(S)[m]()}},q=function(t,d,m){return function(S,k){return new $(t,d,k).update(S)[m]()}},z=function(t,d,m){return function(S,k,W,P){return U["cshake"+t].update(S,k,W,P)[m]()}},j=function(t,d,m){return function(S,k,W,P){return U["kmac"+t].update(S,k,W,P)[m]()}},ae=function(t,d,m,S){for(var k=0;k<g.length;++k){var W=g[k];t[W]=d(m,S,W);}return t},ge=function(t,d){var m=R(t,d,"hex");return m.create=function(){return new $(t,d,t)},m.update=function(S){return m.create().update(S)},ae(m,R,t,d)},O=function(t,d){var m=q(t,d,"hex");return m.create=function(S){return new $(t,d,S)},m.update=function(S,k){return m.create(k).update(S)},ae(m,q,t,d)},v=function(t,d){var m=x[t],S=z(t,d,"hex");return S.create=function(k,W,P){return !W&&!P?U["shake"+t].create(k):new $(t,d,k).bytepad([W,P],m)},S.update=function(k,W,P,_){return S.create(W,P,_).update(k)},ae(S,z,t,d)},M=function(t,d){var m=x[t],S=j(t,d,"hex");return S.create=function(k,W,P){return new ne(t,d,W).bytepad(["KMAC",P],m).bytepad([k],m)},S.update=function(k,W,P,_){return S.create(k,P,_).update(W)},ae(S,j,t,d)},L=[{name:"keccak",padding:E,bits:b,createMethod:ge},{name:"sha3",padding:A,bits:b,createMethod:ge},{name:"shake",padding:T,bits:D,createMethod:O},{name:"cshake",padding:C,bits:D,createMethod:v},{name:"kmac",padding:C,bits:D,createMethod:M}],U={},G=[],H=0;H<L.length;++H)for(var ee=L[H],ce=ee.bits,pe=0;pe<ce.length;++pe){var X=ee.name+"_"+ce[pe];if(G.push(X),U[X]=ee.createMethod(ce[pe],ee.padding),ee.name!=="sha3"){var de=ee.name+ce[pe];G.push(de),U[de]=U[X];}}function $(t,d,m){this.blocks=[],this.s=[],this.padding=d,this.outputBits=m,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(t<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=m>>5,this.extraBytes=(m&31)>>3;for(var S=0;S<50;++S)this.s[S]=0;}$.prototype.update=function(t){if(this.finalized)throw new Error(n);var d,m=typeof t;if(m!=="string"){if(m==="object"){if(t===null)throw new Error(e);if(l&&t.constructor===ArrayBuffer)t=new Uint8Array(t);else if(!Array.isArray(t)&&(!l||!ArrayBuffer.isView(t)))throw new Error(e)}else throw new Error(e);d=!0;}for(var S=this.blocks,k=this.byteCount,W=t.length,P=this.blockCount,_=0,Y=this.s,K,V;_<W;){if(this.reset)for(this.reset=!1,S[0]=this.block,K=1;K<P+1;++K)S[K]=0;if(d)for(K=this.start;_<W&&K<k;++_)S[K>>2]|=t[_]<<y[K++&3];else for(K=this.start;_<W&&K<k;++_)V=t.charCodeAt(_),V<128?S[K>>2]|=V<<y[K++&3]:V<2048?(S[K>>2]|=(192|V>>6)<<y[K++&3],S[K>>2]|=(128|V&63)<<y[K++&3]):V<55296||V>=57344?(S[K>>2]|=(224|V>>12)<<y[K++&3],S[K>>2]|=(128|V>>6&63)<<y[K++&3],S[K>>2]|=(128|V&63)<<y[K++&3]):(V=65536+((V&1023)<<10|t.charCodeAt(++_)&1023),S[K>>2]|=(240|V>>18)<<y[K++&3],S[K>>2]|=(128|V>>12&63)<<y[K++&3],S[K>>2]|=(128|V>>6&63)<<y[K++&3],S[K>>2]|=(128|V&63)<<y[K++&3]);if(this.lastByteIndex=K,K>=k){for(this.start=K-k,this.block=S[P],K=0;K<P;++K)Y[K]^=S[K];fe(Y),this.reset=!0;}else this.start=K;}return this},$.prototype.encode=function(t,d){var m=t&255,S=1,k=[m];for(t=t>>8,m=t&255;m>0;)k.unshift(m),t=t>>8,m=t&255,++S;return d?k.push(S):k.unshift(S),this.update(k),k.length},$.prototype.encodeString=function(t){var d,m=typeof t;if(m!=="string"){if(m==="object"){if(t===null)throw new Error(e);if(l&&t.constructor===ArrayBuffer)t=new Uint8Array(t);else if(!Array.isArray(t)&&(!l||!ArrayBuffer.isView(t)))throw new Error(e)}else throw new Error(e);d=!0;}var S=0,k=t.length;if(d)S=k;else for(var W=0;W<t.length;++W){var P=t.charCodeAt(W);P<128?S+=1:P<2048?S+=2:P<55296||P>=57344?S+=3:(P=65536+((P&1023)<<10|t.charCodeAt(++W)&1023),S+=4);}return S+=this.encode(S*8),this.update(t),S},$.prototype.bytepad=function(t,d){for(var m=this.encode(d),S=0;S<t.length;++S)m+=this.encodeString(t[S]);var k=d-m%d,W=[];return W.length=k,this.update(W),this},$.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var t=this.blocks,d=this.lastByteIndex,m=this.blockCount,S=this.s;if(t[d>>2]|=this.padding[d&3],this.lastByteIndex===this.byteCount)for(t[0]=t[m],d=1;d<m+1;++d)t[d]=0;for(t[m-1]|=2147483648,d=0;d<m;++d)S[d]^=t[d];fe(S);}},$.prototype.toString=$.prototype.hex=function(){this.finalize();for(var t=this.blockCount,d=this.s,m=this.outputBlocks,S=this.extraBytes,k=0,W=0,P="",_;W<m;){for(k=0;k<t&&W<m;++k,++W)_=d[k],P+=f[_>>4&15]+f[_&15]+f[_>>12&15]+f[_>>8&15]+f[_>>20&15]+f[_>>16&15]+f[_>>28&15]+f[_>>24&15];W%t===0&&(fe(d),k=0);}return S&&(_=d[k],P+=f[_>>4&15]+f[_&15],S>1&&(P+=f[_>>12&15]+f[_>>8&15]),S>2&&(P+=f[_>>20&15]+f[_>>16&15])),P},$.prototype.arrayBuffer=function(){this.finalize();var t=this.blockCount,d=this.s,m=this.outputBlocks,S=this.extraBytes,k=0,W=0,P=this.outputBits>>3,_;S?_=new ArrayBuffer(m+1<<2):_=new ArrayBuffer(P);for(var Y=new Uint32Array(_);W<m;){for(k=0;k<t&&W<m;++k,++W)Y[W]=d[k];W%t===0&&fe(d);}return S&&(Y[k]=d[k],_=_.slice(0,P)),_},$.prototype.buffer=$.prototype.arrayBuffer,$.prototype.digest=$.prototype.array=function(){this.finalize();for(var t=this.blockCount,d=this.s,m=this.outputBlocks,S=this.extraBytes,k=0,W=0,P=[],_,Y;W<m;){for(k=0;k<t&&W<m;++k,++W)_=W<<2,Y=d[k],P[_]=Y&255,P[_+1]=Y>>8&255,P[_+2]=Y>>16&255,P[_+3]=Y>>24&255;W%t===0&&fe(d);}return S&&(_=W<<2,Y=d[k],P[_]=Y&255,S>1&&(P[_+1]=Y>>8&255),S>2&&(P[_+2]=Y>>16&255)),P};function ne(t,d,m){$.call(this,t,d,m);}ne.prototype=new $,ne.prototype.finalize=function(){return this.encode(this.outputBits,!0),$.prototype.finalize.call(this)};var fe=function(t){var d,m,S,k,W,P,_,Y,K,V,we,Ae,Ie,be,Ee,Oe,xe,Te,ve,ke,Me,Pe,We,_e,Re,De,Ke,Be,Ne,Fe,Le,Ue,Ge,qe,ze,He,Qe,je,$e,Ve,Ye,Xe,Je,Ze,et,tt,nt,it,ot,rt,st,at,ct,lt,ut,pt,dt,ft,mt,gt,yt,ht,St;for(S=0;S<48;S+=2)k=t[0]^t[10]^t[20]^t[30]^t[40],W=t[1]^t[11]^t[21]^t[31]^t[41],P=t[2]^t[12]^t[22]^t[32]^t[42],_=t[3]^t[13]^t[23]^t[33]^t[43],Y=t[4]^t[14]^t[24]^t[34]^t[44],K=t[5]^t[15]^t[25]^t[35]^t[45],V=t[6]^t[16]^t[26]^t[36]^t[46],we=t[7]^t[17]^t[27]^t[37]^t[47],Ae=t[8]^t[18]^t[28]^t[38]^t[48],Ie=t[9]^t[19]^t[29]^t[39]^t[49],d=Ae^(P<<1|_>>>31),m=Ie^(_<<1|P>>>31),t[0]^=d,t[1]^=m,t[10]^=d,t[11]^=m,t[20]^=d,t[21]^=m,t[30]^=d,t[31]^=m,t[40]^=d,t[41]^=m,d=k^(Y<<1|K>>>31),m=W^(K<<1|Y>>>31),t[2]^=d,t[3]^=m,t[12]^=d,t[13]^=m,t[22]^=d,t[23]^=m,t[32]^=d,t[33]^=m,t[42]^=d,t[43]^=m,d=P^(V<<1|we>>>31),m=_^(we<<1|V>>>31),t[4]^=d,t[5]^=m,t[14]^=d,t[15]^=m,t[24]^=d,t[25]^=m,t[34]^=d,t[35]^=m,t[44]^=d,t[45]^=m,d=Y^(Ae<<1|Ie>>>31),m=K^(Ie<<1|Ae>>>31),t[6]^=d,t[7]^=m,t[16]^=d,t[17]^=m,t[26]^=d,t[27]^=m,t[36]^=d,t[37]^=m,t[46]^=d,t[47]^=m,d=V^(k<<1|W>>>31),m=we^(W<<1|k>>>31),t[8]^=d,t[9]^=m,t[18]^=d,t[19]^=m,t[28]^=d,t[29]^=m,t[38]^=d,t[39]^=m,t[48]^=d,t[49]^=m,be=t[0],Ee=t[1],tt=t[11]<<4|t[10]>>>28,nt=t[10]<<4|t[11]>>>28,Be=t[20]<<3|t[21]>>>29,Ne=t[21]<<3|t[20]>>>29,gt=t[31]<<9|t[30]>>>23,yt=t[30]<<9|t[31]>>>23,Xe=t[40]<<18|t[41]>>>14,Je=t[41]<<18|t[40]>>>14,qe=t[2]<<1|t[3]>>>31,ze=t[3]<<1|t[2]>>>31,Oe=t[13]<<12|t[12]>>>20,xe=t[12]<<12|t[13]>>>20,it=t[22]<<10|t[23]>>>22,ot=t[23]<<10|t[22]>>>22,Fe=t[33]<<13|t[32]>>>19,Le=t[32]<<13|t[33]>>>19,ht=t[42]<<2|t[43]>>>30,St=t[43]<<2|t[42]>>>30,lt=t[5]<<30|t[4]>>>2,ut=t[4]<<30|t[5]>>>2,He=t[14]<<6|t[15]>>>26,Qe=t[15]<<6|t[14]>>>26,Te=t[25]<<11|t[24]>>>21,ve=t[24]<<11|t[25]>>>21,rt=t[34]<<15|t[35]>>>17,st=t[35]<<15|t[34]>>>17,Ue=t[45]<<29|t[44]>>>3,Ge=t[44]<<29|t[45]>>>3,_e=t[6]<<28|t[7]>>>4,Re=t[7]<<28|t[6]>>>4,pt=t[17]<<23|t[16]>>>9,dt=t[16]<<23|t[17]>>>9,je=t[26]<<25|t[27]>>>7,$e=t[27]<<25|t[26]>>>7,ke=t[36]<<21|t[37]>>>11,Me=t[37]<<21|t[36]>>>11,at=t[47]<<24|t[46]>>>8,ct=t[46]<<24|t[47]>>>8,Ze=t[8]<<27|t[9]>>>5,et=t[9]<<27|t[8]>>>5,De=t[18]<<20|t[19]>>>12,Ke=t[19]<<20|t[18]>>>12,ft=t[29]<<7|t[28]>>>25,mt=t[28]<<7|t[29]>>>25,Ve=t[38]<<8|t[39]>>>24,Ye=t[39]<<8|t[38]>>>24,Pe=t[48]<<14|t[49]>>>18,We=t[49]<<14|t[48]>>>18,t[0]=be^~Oe&Te,t[1]=Ee^~xe&ve,t[10]=_e^~De&Be,t[11]=Re^~Ke&Ne,t[20]=qe^~He&je,t[21]=ze^~Qe&$e,t[30]=Ze^~tt&it,t[31]=et^~nt&ot,t[40]=lt^~pt&ft,t[41]=ut^~dt&mt,t[2]=Oe^~Te&ke,t[3]=xe^~ve&Me,t[12]=De^~Be&Fe,t[13]=Ke^~Ne&Le,t[22]=He^~je&Ve,t[23]=Qe^~$e&Ye,t[32]=tt^~it&rt,t[33]=nt^~ot&st,t[42]=pt^~ft&gt,t[43]=dt^~mt&yt,t[4]=Te^~ke&Pe,t[5]=ve^~Me&We,t[14]=Be^~Fe&Ue,t[15]=Ne^~Le&Ge,t[24]=je^~Ve&Xe,t[25]=$e^~Ye&Je,t[34]=it^~rt&at,t[35]=ot^~st&ct,t[44]=ft^~gt&ht,t[45]=mt^~yt&St,t[6]=ke^~Pe&be,t[7]=Me^~We&Ee,t[16]=Fe^~Ue&_e,t[17]=Le^~Ge&Re,t[26]=Ve^~Xe&qe,t[27]=Ye^~Je&ze,t[36]=rt^~at&Ze,t[37]=st^~ct&et,t[46]=gt^~ht&lt,t[47]=yt^~St&ut,t[8]=Pe^~be&Oe,t[9]=We^~Ee&xe,t[18]=Ue^~_e&De,t[19]=Ge^~Re&Ke,t[28]=Xe^~qe&He,t[29]=Je^~ze&Qe,t[38]=at^~Ze&tt,t[39]=ct^~et&nt,t[48]=ht^~lt&pt,t[49]=St^~ut&dt,t[0]^=I[S],t[1]^=I[S+1];};if(a)wt.exports=U;else {for(H=0;H<G.length;++H)r[G[H]]=U[G[H]];c&&define(function(){return U});}})();});h();h();h();var me="graz-reconnect-session";h();h();var nn=(g=>(g.KEPLR="keplr",g.LEAP="leap",g.VECTIS="vectis",g.COSMOSTATION="cosmostation",g.WALLETCONNECT="walletconnect",g.WC_KEPLR_MOBILE="wc_keplr_mobile",g.WC_LEAP_MOBILE="wc_leap_mobile",g.WC_COSMOSTATION_MOBILE="wc_cosmostation_mobile",g.WC_CLOT_MOBILE="wc_clot_mobile",g.METAMASK_SNAP_LEAP="metamask_snap_leap",g.METAMASK_SNAP_COSMOS="metamask_snap_cosmos",g.STATION="station",g.XDEFI="xdefi",g.CAPSULE="capsule",g.COSMIFRAME="cosmiframe",g.COMPASS="compass",g.INITIA="initia",g.OKX="okx",g))(nn||{}),on=["keplr","leap","vectis","cosmostation","walletconnect","wc_keplr_mobile","wc_leap_mobile","wc_cosmostation_mobile","wc_clot_mobile","metamask_snap_leap","station","xdefi","capsule","metamask_snap_cosmos","cosmiframe","compass","initia","okx"];var li={iframeOptions:null,recentChainIds:null,chains:null,chainsConfig:null,capsuleConfig:null,capsuleState:null,multiChainFetchConcurrency:3,walletType:"keplr",walletConnect:{options:null,web3Modal:null},walletDefaultOptions:null,_notFoundFn:()=>null,_onReconnectFailed:()=>null,_reconnect:!1,_reconnectConnector:null},Se={accounts:null,activeChainIds:null,status:"disconnected",wcSignClients:new Map,capsuleClient:null},ui={name:"graz-session",version:2,partialize:e=>({accounts:e.accounts,activeChainIds:e.activeChainIds}),storage:createJSONStorage(()=>sessionStorage)},pi={name:"graz-internal",partialize:e=>({recentChainIds:e.recentChainIds,_reconnect:e._reconnect,_reconnectConnector:e._reconnectConnector,walletType:e.walletType}),version:2},w=create(subscribeWithSelector(persist(()=>Se,ui))),p=create(subscribeWithSelector(persist(()=>li,pi)));h();var On=ai(cn());h();var At=()=>{var E,A;if(!((E=p.getState().capsuleConfig)!=null&&E.apiKey)||!((A=p.getState().capsuleConfig)!=null&&A.env))throw new Error("Capsule configuration is not set");let e=()=>u(void 0,null,function*(){var b,D;let y=(yield import('@leapwallet/cosmos-social-login-capsule-provider')).CapsuleProvider,I=new y({apiKey:(b=p.getState().capsuleConfig)==null?void 0:b.apiKey,env:(D=p.getState().capsuleConfig)==null?void 0:D.env});return w.setState({capsuleClient:I}),I});return {init:e,enable:y=>u(void 0,null,function*(){let I=typeof y=="string"?[y]:y,b=w.getState().capsuleClient;b||(b=yield e()),p.setState({capsuleState:{showModal:!0,chainId:I}});}),onAfterLoginSuccessful:()=>u(void 0,null,function*(){var g;let y=w.getState().capsuleClient,{chains:I}=p.getState();if(!y)throw new Error("Capsule client is not initialized");if(!I)throw new Error("Chains are not set");yield y.enable();let b=(g=p.getState().capsuleState)==null?void 0:g.chainId;if(!b)throw new Error("Chain ids are not set");let D=Object.fromEntries(yield Promise.all(b.map(x=>u(void 0,null,function*(){let R=yield y.getAccount(x);return [x,{address:fromBech32(R.address).data,bech32Address:R.address,ethereumHexAddress:yield ie(R.pubkey),algo:R.algo,name:R.username||"",pubKey:R.pubkey,isKeystone:!1,isNanoLedger:!1}]}))));w.setState(x=>({accounts:F(F({},x.accounts||{}),D)})),p.setState(x=>({recentChainIds:[...x.recentChainIds||[],...b].filter((R,q,z)=>z.indexOf(R)===q)})),w.setState(x=>({activeChainIds:[...x.activeChainIds||[],...b].filter((R,q,z)=>z.indexOf(R)===q)})),p.setState({walletType:"capsule",_reconnect:!1,_reconnectConnector:"capsule"}),w.setState({status:"connected"}),typeof window!="undefined"&&window.sessionStorage.setItem(me,"Active"),p.setState({capsuleState:null});}),getKey:y=>u(void 0,null,function*(){let I=w.getState().capsuleClient;if(!I)throw new Error("Capsule client is not initialized");let b=yield I.getAccount(y);return {address:fromBech32(b.address).data,bech32Address:b.address,ethereumHexAddress:yield ie(b.pubkey),algo:b.algo,name:b.username||"",pubKey:b.pubkey,isKeystone:!1,isNanoLedger:!1}}),getOfflineSignerAuto:y=>u(void 0,null,function*(){let I=w.getState().capsuleClient;if(!I)throw new Error("Capsule client is not initialized");return I.getOfflineSignerDirect(y)}),getOfflineSignerDirect:y=>{let I=w.getState().capsuleClient;if(!I)throw new Error("Capsule client is not initialized");return I.getOfflineSignerDirect(y)},signDirect:(...y)=>u(void 0,null,function*(){let[I,b,D]=y,g=w.getState().capsuleClient;if(!g)throw new Error("Capsule client is not initialized");return g.signDirect(I,b,{bodyBytes:D.bodyBytes,authInfoBytes:D.authInfoBytes,chainId:D.chainId,accountNumber:D.accountNumber})}),signAmino:(...y)=>u(void 0,null,function*(){let[I,b,D,g]=y,x=w.getState().capsuleClient;if(!x)throw new Error("Capsule client is not initialized");return x.signAmino(I,b,D,g)}),signArbitrary:(y,I,b)=>u(void 0,null,function*(){let D=w.getState().capsuleClient;if(!D)throw new Error("Capsule client is not initialized");let g=yield D.getAccount(y);if(!g)throw new Error(`Wallet not connected to account ${I}`);let x=(()=>{switch(g.algo){case"secp256k1":return encodeSecp256k1Pubkey(g.pubkey);case"ed25519":return encodeEd25519Pubkey(g.pubkey);default:throw new Error("sr25519 public key algorithm is not supported")}})();return {signature:yield D.signArbitrary(y,I,b),pub_key:{type:g.algo==="secp256k1"?pubkeyType.secp256k1:pubkeyType.ed25519,value:x.value}}}),experimentalSuggestChain:(...y)=>u(void 0,null,function*(){yield Promise.reject(new Error("Capsule does not support experimentalSuggestChain"));}),getOfflineSigner:y=>{let I=w.getState().capsuleClient;if(!I)throw new Error("Capsule client is not initialized");return I.getOfflineSigner(y)},getOfflineSignerAmino:y=>{let I=w.getState().capsuleClient;if(!I)throw new Error("Capsule client is not initialized");return I.getOfflineSignerAmino(y)}}};h();var It=()=>{if(typeof window.compass!="undefined"){let e=window.compass;return Object.assign(e,{subscription:s=>{let i=()=>{Z(),s();};return window.addEventListener("leap_keystorechange",i),()=>{window.removeEventListener("leap_keystorechange",i);}},setDefaultOptions:s=>{e.defaultOptions=s;}})}throw p.getState()._notFoundFn(),new Error("window.leap is not defined")};h();var bt=()=>{let e=p.getState();if(!e.iframeOptions)throw e._notFoundFn(),new Error("no iframe options set");if(!isInIframe())throw e._notFoundFn(),new Error("not in iframe");if(!e.iframeOptions.allowedIframeParentOrigins.length)throw e._notFoundFn(),new Error("no iframe allowed origins");let n=new Cosmiframe(e.iframeOptions.allowedIframeParentOrigins).getKeplrClient();return {enable:n.enable.bind(n),getKey:n.getKey.bind(n),getOfflineSigner:n.getOfflineSigner.bind(n),getOfflineSignerAuto:n.getOfflineSignerAuto.bind(n),getOfflineSignerOnlyAmino:n.getOfflineSignerOnlyAmino.bind(n),experimentalSuggestChain:n.experimentalSuggestChain.bind(n),signDirect:n.signDirect.bind(n),signAmino:n.signAmino.bind(n)}};h();var fn={},mn=()=>{let e=window.ethereum,n=window.cosmos;if(e)return {init:()=>u(void 0,null,function*(){var T;let i=yield e.request({method:"web3_clientVersion"});if(!i.includes("MetaMask"))throw new Error("Metamask is not installed");if(typeof window.okxwallet!="undefined"&&window.okxwallet.isOkxWallet)throw new Error("You have OKX Wallet installed. Please disable and reload the page to use Metamask Snap.");let c=(T=i.split("MetaMask/v")[1])==null?void 0:T.split(".")[0];if(!(Number(c)>=11))throw new Error("Metamask Snap is not supported in this version");return (yield isSnapInstalled())||(yield installSnap()),window.cosmos=new CosmosSnap,n=window.cosmos,!0}),enable:i=>u(void 0,null,function*(){(yield isSnapInstalled())||(yield installSnap());}),getOfflineSigner:i=>n.getOfflineSigner(i),experimentalSuggestChain:i=>u(void 0,null,function*(){var a,c,l,f;if(!i.stakeCurrency)throw new Error("Chain info is missing stakeCurrency");if(!i.bech32Config)throw new Error("Chain is missing bech32 config");yield n.experimentalSuggestChain(J(F({},i),{stakeCurrency:i.stakeCurrency,bech32Config:i.bech32Config,nodeProvider:J(F({},i.nodeProvider),{name:(c=(a=i.nodeProvider)==null?void 0:a.name)!=null?c:"",email:(f=(l=i.nodeProvider)==null?void 0:l.email)!=null?f:""})}));}),signAmino:(i,a,c)=>u(void 0,null,function*(){return n.signAmino(i,a,c)}),getKey:i=>u(void 0,null,function*(){if(typeof fn[i]!="undefined")return fn[i];let a=yield n.getKey(i);return F({ethereumHexAddress:yield ie(a.pubKey)},a)}),getOfflineSignerAuto:i=>u(void 0,null,function*(){return (yield n.getKey(i)).isNanoLedger?n.getOfflineSignerOnlyAmino(i):n.getOfflineSigner(i)}),getOfflineSignerOnlyAmino:i=>n.getOfflineSignerOnlyAmino(i),signDirect:(i,a,c)=>u(void 0,null,function*(){return n.signDirect(i,a,c)}),signArbitrary:(i,a,c)=>u(void 0,null,function*(){return n.signArbitrary(i,a,c)}),disable:i=>u(void 0,null,function*(){i&&(yield n.deleteChain(i));})};throw p.getState()._notFoundFn(),new Error("window.ethereum is not defined")};h();var Et=()=>{var e;if(typeof((e=window.cosmostation)==null?void 0:e.providers.keplr)!="undefined"){let n=window.cosmostation.providers.keplr;return Object.assign(n,{subscription:i=>{let a=()=>{Z(),i();};return window.addEventListener("cosmostation_keystorechange",a),()=>{window.removeEventListener("cosmostation_keystorechange",a);}},setDefaultOptions:i=>{n.defaultOptions=i;}})}throw p.getState()._notFoundFn(),new Error("window.cosmostation.providers.keplr is not defined")};h();var Ai=e=>{let{bodyBytes:n,authInfoBytes:o,chainId:r,accountNumber:s}=e;if(!n||!o||!r||!s)throw new Error("Invalid sign doc");return {bodyBytes:n,authInfoBytes:o,chainId:r,accountNumber:s}},Ii=e=>`${e.slice(0,6)}...${e.slice(-6)}`,yn=()=>{if(typeof window.initia!="undefined"){let e=window.initia;return {enable:()=>u(void 0,null,function*(){yield e.getAddress();}),getKey:C=>u(void 0,null,function*(){let E=e.getOfflineSigner(C),[A]=yield E.getAccounts();if(!A)throw new Error("Wallet connection failed");let y=(()=>{switch(A.algo){case"secp256k1":return rawSecp256k1PubkeyToRawAddress(A.pubkey);case"ed25519":return rawEd25519PubkeyToRawAddress(A.pubkey);default:throw new Error("sr25519 public key algorithm is not supported")}})();return {name:Ii(A.address),algo:A.algo,pubKey:A.pubkey,bech32Address:A.address,ethereumHexAddress:yield ie(A.pubkey),address:y,isNanoLedger:!1,isKeystone:!1}}),getOfflineSigner:C=>{let E=e.getOfflineSigner(C),A=e.getOfflineSignerOnlyAmino(C);return {getAccounts:E.getAccounts.bind(E),signDirect:E.signDirect.bind(E),signAmino:A.signAmino.bind(A)}},getOfflineSignerAuto:C=>Promise.resolve(e.getOfflineSigner(C)),getOfflineSignerOnlyAmino:C=>e.getOfflineSignerOnlyAmino(C),experimentalSuggestChain:C=>e.requestAddInitiaLayer({chain_id:C.chainId,chain_name:C.chainName,bech32_prefix:"init",bech32_config:C.bech32Config,slip44:C.bip44.coinType,logo_URIs:{png:C.chainSymbolImageUrl},fees:{fee_tokens:C.feeCurrencies.map(E=>{var A,y,I;return {denom:E.coinDenom,amount:E.coinMinimalDenom,low_gas_price:(A=E.gasPriceStep)==null?void 0:A.low,average_gas_price:(y=E.gasPriceStep)==null?void 0:y.average,high_gas_price:(I=E.gasPriceStep)==null?void 0:I.high}})},apis:{rpc:[{address:C.rpc}],rest:[{address:C.rest}]}}),signDirect:(...C)=>{let[E,A,y]=C;return e.getOfflineSigner(E).signDirect(A,Ai(y))},signAmino:(...C)=>{let[E,A,y]=C;return e.getOfflineSignerOnlyAmino(E).signAmino(A,y)},signArbitrary:(C,E,A)=>u(void 0,null,function*(){let b=(yield e.getOfflineSigner(C).getAccounts()).find(x=>x.address===E);if(!b)throw new Error(`Wallet not connected to account ${E}`);let D=(()=>{switch(b.algo){case"secp256k1":return encodeSecp256k1Pubkey(b.pubkey);case"ed25519":return encodeEd25519Pubkey(b.pubkey);default:throw new Error("sr25519 public key algorithm is not supported")}})();return {signature:yield e.signArbitrary(A),pub_key:{type:b.algo==="secp256k1"?pubkeyType.secp256k1:pubkeyType.ed25519,value:D.value}}}),subscription:C=>{let E=()=>{Z(),C();};return window.addEventListener("initia_keystorechange",E),()=>{window.removeEventListener("initia_keystorechange",E);}}}}throw p.getState()._notFoundFn(),new Error("window.initia is not defined")};h();var Ot=()=>{var e;if(typeof((e=window.okxwallet)==null?void 0:e.keplr)!="undefined"){let n=window.okxwallet.keplr;return Object.assign(n,{subscription:i=>{var c;let a=()=>{Z(),i();};return (c=window.okxwallet)==null||c.on("accountsChanged",a),()=>{var l;(l=window.okxwallet)==null||l.removeListener("accountsChanged",a);}},setDefaultOptions:i=>{n.defaultOptions=i;}})}throw p.getState()._notFoundFn(),new Error("window.okxwallet.keplr is not defined")};h();var xt=()=>{if(typeof window.keplr!="undefined"){let e=window.keplr;return Object.assign(e,{subscription:s=>{let i=()=>{Z(),s();};return window.addEventListener("keplr_keystorechange",i),()=>{window.removeEventListener("keplr_keystorechange",i);}},setDefaultOptions:s=>{e.defaultOptions=s;}})}throw p.getState()._notFoundFn(),new Error("window.keplr is not defined")};h();var Tt=()=>{if(typeof window.leap!="undefined"){let e=window.leap;return Object.assign(e,{subscription:i=>{let a=()=>{Z(),i();};return window.addEventListener("leap_keystorechange",a),()=>{window.removeEventListener("leap_keystorechange",a);}},setDefaultOptions:i=>{e.defaultOptions=i;},getKey:i=>u(void 0,null,function*(){var c;let a=yield e.getKey(i);return J(F({},a),{ethereumHexAddress:(c=a.ethereumHexAddress)!=null?c:ie(a.pubKey)})})})}throw p.getState()._notFoundFn(),new Error("window.leap is not defined")};h();h();var vt={},hn=e=>{let n=window.ethereum;if(n&&e){let o=()=>u(void 0,null,function*(){return yield n.request({method:"wallet_getSnaps"})}),r=g=>u(void 0,null,function*(){try{let x=yield o();return Object.values(x).find(R=>R.id===e.id&&(!g||R.version===g))}catch(x){return}}),s=()=>u(void 0,null,function*(){yield n.request({method:"wallet_requestSnaps",params:{[e.id]:e.params||{}}});}),i=()=>u(void 0,null,function*(){var j;let g=yield n.request({method:"web3_clientVersion"});if(!g.includes("MetaMask"))throw new Error("Metamask is not installed");if(typeof window.okxwallet!="undefined"&&window.okxwallet.isOkxWallet)throw new Error("You have OKX Wallet installed. Please disable and reload the page to use Metamask Snap.");let R=(j=g.split("MetaMask/v")[1])==null?void 0:j.split(".")[0];if(!(Number(R)>=11))throw new Error("Metamask Snap is not supported in this version");return (yield r())||(yield s()),!0}),a=g=>u(void 0,null,function*(){(yield r())||(yield s());}),c=(g,x,R)=>u(void 0,null,function*(){let q=yield n.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"signDirect",params:{chainId:g,signerAddress:x,signDoc:R}}}}),z=R.accountNumber,j=new bi(z.low,z.high,z.unsigned);return {signature:q.signature,signed:J(F({},q.signed),{accountNumber:j.toString(),authInfoBytes:new Uint8Array(Object.values(q.signed.authInfoBytes)),bodyBytes:new Uint8Array(Object.values(q.signed.bodyBytes))})}}),l=(g,x,R)=>u(void 0,null,function*(){return yield n.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"signAmino",params:{chainId:g,signerAddress:x,signDoc:R}}}})}),f=g=>u(void 0,null,function*(){if(typeof vt[g]!="undefined")return vt[g];let x=yield n.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"getKey",params:{chainId:g}}}});if(!x)throw new Error("No response from Metamask");return x.pubKey=Uint8Array.from(Object.values(x.pubkey)),delete x.pubkey,vt[g]=x,vt[g]}),T=g=>u(void 0,null,function*(){let x=yield f(g);return {address:x.bech32Address,algo:x.algo,pubkey:x.pubKey}}),C=(...g)=>u(void 0,null,function*(){let[x,R,q,z]=g;return yield l(x,R,q)}),E=(...g)=>u(void 0,null,function*(){let[x,R,q]=g;return yield c(x,R,q)}),y=g=>({getAccounts:()=>u(void 0,null,function*(){return [yield T(g)]}),signAmino:(x,R)=>C(g,x,R)});return {enable:a,experimentalSuggestChain:(...g)=>u(void 0,null,function*(){yield i(),yield n.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"suggestChain",params:{chainInfo:g[0]}}}});}),getKey:f,getOfflineSigner:g=>({getAccounts:()=>u(void 0,null,function*(){return [yield T(g)]}),signDirect:(x,R)=>E(g,x,R),signAmino:(x,R)=>C(g,x,R)}),getOfflineSignerAuto:g=>u(void 0,null,function*(){return y(g)}),getOfflineSignerOnlyAmino:y,init:i,signAmino:C,signDirect:E}}throw p.getState()._notFoundFn(),new Error("window.ethereum is not defined")};var Sn=()=>hn({id:"npm:@leapwallet/metamask-cosmos-snap"});h();var kt=()=>{if(typeof window.station!="undefined"){let e=window.station.keplr;return {subscription:i=>{let a=()=>{Z(),i();};return window.addEventListener("station_wallet_change",a),()=>{window.removeEventListener("station_wallet_change",a);}},getKey:i=>u(void 0,null,function*(){let a=yield e.getKey(i);return F({isKeystone:!1,ethereumHexAddress:yield ie(a.pubKey)},a)}),getOfflineSigner:i=>{try{let a=e.getOfflineSignerOnlyAmino(i);return Object.assign(a,{signDirect:(f,T)=>{throw new Error("signDirect not supported by Station")}})}catch(a){throw console.error(a),a}},experimentalSuggestChain:i=>u(void 0,null,function*(){try{if(!i.stakeCurrency)throw new Error("Chain info is missing stakeCurrency");if(!i.bech32Config)throw new Error("Chain info is missing stakeCurrency");let a=Object.assign(i,{bech32Config:i.bech32Config,chainSymbolImageUrl:i.chainSymbolImageUrl||"",stakeCurrency:{coinDecimals:i.stakeCurrency.coinDecimals,coinDenom:i.stakeCurrency.coinDenom,coinImageUrl:i.stakeCurrency.coinImageUrl||"",coinMinimalDenom:i.stakeCurrency.coinMinimalDenom},currencies:i.currencies.map(c=>({coinDecimals:c.coinDecimals,coinDenom:c.coinDenom,coinImageUrl:c.coinImageUrl||"",coinMinimalDenom:c.coinMinimalDenom})),feeCurrencies:i.feeCurrencies.map(c=>{var l,f,T;return {coinDecimals:c.coinDecimals,coinDenom:c.coinDenom,coinImageUrl:c.coinImageUrl||"",coinMinimalDenom:c.coinMinimalDenom,gasPriceStep:{average:((l=c.gasPriceStep)==null?void 0:l.average)||0,high:((f=c.gasPriceStep)==null?void 0:f.high)||0,low:((T=c.gasPriceStep)==null?void 0:T.low)||0}}})});yield e.experimentalSuggestChain(a);}catch(a){throw console.error(a),a}}),enable:i=>e.enable(i),disable:i=>e.disable(i),getOfflineSignerAuto:i=>e.getOfflineSignerAuto(i),getOfflineSignerOnlyAmino:i=>e.getOfflineSignerOnlyAmino(i),signDirect:()=>e.signDirect(),signAmino:(i,a,c,l)=>e.signAmino(i,a,c)}}throw p.getState()._notFoundFn(),new Error("window.station is not defined")};h();var Mt=()=>{if(typeof window.vectis!="undefined"){let e=window.vectis.cosmos;return {enable:c=>e.enable(c),getOfflineSigner:c=>e.getOfflineSigner(c),getOfflineSignerAuto:c=>e.getOfflineSignerAuto(c),getKey:c=>u(void 0,null,function*(){let l=yield e.getKey(c);return {address:fromBech32(l.address).data,algo:l.algo,bech32Address:l.address,ethereumHexAddress:yield ie(l.pubKey),name:l.name,pubKey:l.pubKey,isKeystone:!1,isNanoLedger:l.isNanoLedger}}),subscription:c=>{let l=()=>{Z(),c();};return window.addEventListener("vectis_accountChanged",l),()=>{window.removeEventListener("vectis_accountChanged",l);}},getOfflineSignerOnlyAmino:(...c)=>{let[l]=c;return e.getOfflineSignerAmino(l)},experimentalSuggestChain:(...c)=>u(void 0,null,function*(){let[l]=c,{stakeCurrency:f}=l;if(!l.bech32Config)throw new Error("Chain is missing bech32 config");if(!f)throw new Error("Chain info is missing stakeCurrency");let T=J(F({},l),{rpcUrl:l.rpc,restUrl:l.rest,prettyName:l.chainName.replace(" ",""),bech32Prefix:l.bech32Config.bech32PrefixAccAddr,stakeCurrency:f});return e.suggestChains([T])}),signDirect:(...c)=>u(void 0,null,function*(){var T;let{1:l,2:f}=c;return e.signDirect(l,{bodyBytes:f.bodyBytes||Uint8Array.from([]),authInfoBytes:f.authInfoBytes||Uint8Array.from([]),accountNumber:bi.fromString(((T=f.accountNumber)==null?void 0:T.toString())||"",!1),chainId:f.chainId||""})}),signAmino:(...c)=>u(void 0,null,function*(){let{1:l,2:f}=c;return e.signAmino(l,f)})}}throw p.getState()._notFoundFn(),new Error("window.vectis is not defined")};h();h();var le=()=>{if(typeof window!="undefined"){let e=navigator.userAgent;return !!(/android/i.test(e)||/iPad|iPhone|iPod/.test(e))}return !1},Cn=()=>le()&&navigator.userAgent.toLowerCase().includes("android"),wn=()=>le()&&(navigator.userAgent.toLowerCase().includes("iphone")||navigator.userAgent.toLowerCase().includes("ipad"));h();var Gt=(e,n,o=new Error("Promise timed out"))=>{let r=new Promise((s,i)=>{setTimeout(()=>{i(o);},n);});return Promise.race([e,r])};var ue=e=>{var j,ae,ge;if(!((ge=(ae=(j=p.getState().walletConnect)==null?void 0:j.options)==null?void 0:ae.projectId)!=null&&ge.trim()))throw new Error("walletConnect.options.projectId is not defined");let n=(e==null?void 0:e.walletType)||"walletconnect",o=(e==null?void 0:e.encoding)||"base64",r=O=>{if(!e)return;let{appUrl:v,formatNativeUrl:M}=e;if(le()){if(Cn())if(!O)window.open(v.mobile.android,"_self","noreferrer noopener");else {let L=M(v.mobile.android,O,"android");window.open(L,"_self","noreferrer noopener");}if(wn())if(!O)window.open(v.mobile.ios,"_self","noreferrer noopener");else {let L=M(v.mobile.ios,O,"ios");window.open(L,"_self","noreferrer noopener");}}},s=()=>{let{wcSignClients:O}=w.getState();if(!O.get(n))throw new Error("walletConnect.signClient is not defined");O.delete(n),w.setState({wcSignClients:O}),p.setState({_reconnect:!1,_reconnectConnector:null,recentChainIds:null});},i=O=>u(void 0,null,function*(){let{wcSignClients:v}=w.getState(),M=v.get(n);if(!M)throw new Error("walletConnect.signClient is not defined");if(!O)throw new Error("No wallet connect session");yield M.disconnect({topic:O,reason:getSdkError("USER_DISCONNECTED")}),yield l(M);}),a=O=>{try{let{wcSignClients:v}=w.getState(),M=v.get(n);if(!M)throw new Error("walletConnect.signClient is not defined");let L=M.session.getAll().at(-1);if(!L)return;if(!(L.expiry*1e3>Date.now()+1e3))throw i(L.topic),new Error("invalid session");try{let G=M.find({requiredNamespaces:{cosmos:{methods:["cosmos_getAccounts","cosmos_signAmino","cosmos_signDirect"],chains:O.map(H=>`cosmos:${H}`),events:["chainChanged","accountsChanged"]}}});if(!G.length)throw new Error("no session");return G.at(-1)}catch(G){if(!G.message.toLowerCase().includes("no matching key"))throw G}return L}catch(v){if(!v.message.toLowerCase().includes("no matching key"))throw v}},c=O=>{try{return a(O)}catch(v){return}},l=O=>u(void 0,null,function*(){try{let v=O.core.pairing.pairings.getAll({active:!1});if(!v.length)return;yield Promise.all(v.map(M=>u(void 0,null,function*(){yield O.core.pairing.pairings.delete(M.topic,{code:7001,message:"clear pairing"});})));}catch(v){if(!v.message.toLowerCase().includes("no matching key"))throw v}}),f=()=>u(void 0,null,function*(){let{walletConnect:O}=p.getState();if(!(O!=null&&O.options))throw new Error("walletConnect.options is not defined");let{wcSignClients:v}=w.getState(),M=v.get(n);if(M)return M;let L=yield SignClient.init(O.options);return v.set(n,L),w.setState({wcSignClients:v}),L}),T=O=>{let{wcSignClients:v}=w.getState(),M=v.get(n);if(!M)return ()=>{};let L=U=>{let G=w.getState().accounts;if(U.params.event.name==="accountsChanged"&&G&&!Object.values(G).map(H=>H.bech32Address).includes(U.params.event.data[0])){let H=U.params.chainId.split(":")[1];H&&C([H]);}else O();};return M.events.on("session_delete",s),M.events.on("session_expire",s),M.events.on("session_event",L),()=>{M.events.off("session_delete",s),M.events.off("session_expire",s),M.events.off("session_event",L);}},C=O=>u(void 0,null,function*(){var pe;let v=typeof O=="string"?[O]:O,{wcSignClients:M}=w.getState(),L=M.get(n);if(!L)throw new Error("enable walletConnect.signClient is not defined");let{walletConnect:U,chains:G}=p.getState();if(!((pe=U==null?void 0:U.options)!=null&&pe.projectId))throw new Error("walletConnect.options.projectId is not defined");let{Web3Modal:H}=yield import('@web3modal/standalone'),ee=new H(F({projectId:U.options.projectId,walletConnectVersion:2,enableExplorer:!1,explorerRecommendedWalletIds:"NONE"},U.web3Modal)),ce=c(v);if(!ce){let{uri:X,approval:de}=yield Gt(L.connect({requiredNamespaces:{cosmos:{methods:["cosmos_getAccounts","cosmos_signAmino","cosmos_signDirect"],chains:v.map(ne=>`cosmos:${ne}`),events:["chainChanged","accountsChanged"]}}}),15e3,new Error("Connection timeout"));if(!X)throw new Error("No wallet connect uri");e?r(X):yield ee.openModal({uri:X});let $=ne=>u(void 0,null,function*(){return ne.aborted?Promise.reject(new Error("User closed wallet connect")):new Promise((fe,t)=>{de().then(d=>{let m=d.sessionProperties;if(!m)return t(new Error("No session properties"));let S=JSON.parse(String(m.keys));if(S.length===0)return t(new Error("No accounts"));if(!S[0])return t(new Error("No accounts"));let W={};return S.forEach(P=>u(void 0,null,function*(){W[P.chainId]={address:P.address,algo:P.algo,bech32Address:P.bech32Address,ethereumHexAddress:yield ie(P.pubKey),isNanoLedger:P.isNanoLedger,isKeystone:P.isKeystone,name:P.name,pubKey:P.pubKey};})),w.setState(P=>({accounts:F(F({},P.accounts||{}),W)})),fe(d)}).catch(t),ne.addEventListener("abort",()=>{t(new Error("User closed wallet connect"));},{once:!0});})});try{let ne=new AbortController,fe=ne.signal;ee.subscribeModal(t=>{t.open||ne.abort();}),yield $(fe);}catch(ne){if(ee.closeModal(),ne instanceof Error&&!ne.message.toLowerCase().includes("no matching key"))return Promise.reject(ne)}return e||ee.closeModal(),Promise.resolve()}try{yield Gt((()=>u(void 0,null,function*(){let X=Object.fromEntries(yield Promise.all(v.map(de=>u(void 0,null,function*(){return [de,yield A(de)]}))));w.setState({accounts:X});}))(),15e3,new Error("Connection timeout"));}catch(X){if(i(ce.topic),!X.message.toLowerCase().includes("no matching key"))throw X}}),E=O=>u(void 0,null,function*(){var G;let{wcSignClients:v}=w.getState(),M=v.get(n);if(!M)throw new Error("walletConnect.signClient is not defined");let L=(G=a([O]))==null?void 0:G.topic;if(!L)throw new Error("No wallet connect session");let U=yield M.request({topic:L,chainId:`cosmos:${O}`,request:{method:"cosmos_getAccounts",params:{}}});if(!U[0])throw new Error("No wallet connect account");return {address:U[0].address,algo:U[0].algo,pubkey:new Uint8Array(Buffer.from(U[0].pubkey,o))}}),A=O=>u(void 0,null,function*(){let v=a([O]);if(!(v!=null&&v.topic))throw new Error("No wallet connect session");let M=v.sessionProperties&&JSON.parse(String(v.sessionProperties.keys))[0];if(!M)throw new Error("No wallet connect key");return M}),y=(...O)=>u(void 0,null,function*(){var X,de;let[v,M,L]=O,{accounts:U,wcSignClients:G}=w.getState(),H=G.get(n);if(!H)throw new Error("walletConnect.signClient is not defined");if(!U)throw new Error("account is not defined");let ee=(X=a([v]))==null?void 0:X.topic;if(!ee)throw new Error("No wallet connect session");if(!L.bodyBytes)throw new Error("No bodyBytes");if(!L.authInfoBytes)throw new Error("No authInfoBytes");let ce={topic:ee,chainId:`cosmos:${v}`,request:{method:"cosmos_signDirect",params:{signerAddress:M,signDoc:J(F({},L),{bodyBytes:Buffer.from(L.bodyBytes).toString(o),authInfoBytes:Buffer.from(L.authInfoBytes).toString(o),accountNumber:(de=L.accountNumber)==null?void 0:de.toString()})}}};return r(),yield H.request(ce)}),I=(...O)=>u(void 0,null,function*(){let[v,M,L]=O,{signature:U,signed:G}=yield y(v,M,L);return {signed:{chainId:G.chainId,accountNumber:bi.fromString(G.accountNumber,!1),authInfoBytes:new Uint8Array(Buffer.from(G.authInfoBytes,o)),bodyBytes:new Uint8Array(Buffer.from(G.bodyBytes,o))},signature:U}}),b=(...O)=>u(void 0,null,function*(){var X;let[v,M,L,U]=O,{wcSignClients:G}=w.getState(),H=G.get(n),{accounts:ee}=w.getState();if(!H)throw new Error("walletConnect.signClient is not defined");if(!ee)throw new Error("account is not defined");let ce=(X=a([v]))==null?void 0:X.topic;if(!ce)throw new Error("No wallet connect session");return r(),yield H.request({topic:ce,chainId:`cosmos:${v}`,request:{method:"cosmos_signDirect",params:{signerAddress:M,signDoc:L}}})}),D=(...O)=>u(void 0,null,function*(){let[v,M,L,U]=O;return yield b(v,M,L)}),g=O=>({getAccounts:()=>u(void 0,null,function*(){return [yield E(O)]}),signDirect:(v,M)=>I(O,v,M)}),x=O=>({getAccounts:()=>u(void 0,null,function*(){return [yield E(O)]}),signAmino:(v,M)=>D(O,v,M)});return {enable:C,disable:O=>u(void 0,null,function*(){var L;let{wcSignClients:v}=w.getState(),M=v.get(n);if(O===void 0){let U=M==null?void 0:M.session.getAll();U!==void 0&&(yield Promise.all(U.map(G=>i(G.topic))));}else typeof O=="string"?yield i((L=a([O]))==null?void 0:L.topic):yield Promise.all(O.map(U=>{var G;return i((G=a([U]))==null?void 0:G.topic)}));(M==null?void 0:M.session.getAll().length)===0&&s();}),experimentalSuggestChain:(...O)=>u(void 0,null,function*(){yield Promise.reject(new Error("WalletConnect does not support experimentalSuggestChain"));}),getKey:A,getOfflineSigner:O=>({getAccounts:()=>u(void 0,null,function*(){return [yield E(O)]}),signDirect:(v,M)=>I(O,v,M),signAmino:(v,M)=>D(O,v,M)}),getOfflineSignerAuto:O=>u(void 0,null,function*(){return (yield A(O)).isNanoLedger?x(O):g(O)}),getOfflineSignerOnlyAmino:x,signAmino:D,signDirect:I,subscription:T,init:f}};h();var An=()=>{var n,o,r;if(!((r=(o=(n=p.getState().walletConnect)==null?void 0:n.options)==null?void 0:o.projectId)!=null&&r.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!le())throw new Error("WalletConnect Clot mobile is only supported in mobile");let e={encoding:"base64",appUrl:{mobile:{android:"clot://",ios:"clot://"}},walletType:"wc_clot_mobile",formatNativeUrl:(s,i,a)=>{let c=s.replaceAll("/","").replaceAll(":",""),l=encodeURIComponent(i);switch(a){case"ios":return `${c}://wcV2?${l}`;default:return `${c}://wc?uri=${l}`}}};return ue(e)};h();var In=()=>{var n,o,r;if(!((r=(o=(n=p.getState().walletConnect)==null?void 0:n.options)==null?void 0:o.projectId)!=null&&r.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!le())throw new Error("WalletConnect Cosmostation mobile is only supported in mobile");let e={encoding:"hex",appUrl:{mobile:{ios:"cosmostation://",android:"cosmostation://"}},walletType:"wc_cosmostation_mobile",formatNativeUrl:(s,i,a)=>`${s.replaceAll("/","").replaceAll(":","")}://wc?${i}`};return ue(e)};h();var bn=()=>{var n,o,r;if(!((r=(o=(n=p.getState().walletConnect)==null?void 0:n.options)==null?void 0:o.projectId)!=null&&r.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!le())throw new Error("WalletConnect Keplr mobile is only supported in mobile");let e={encoding:"base64",appUrl:{mobile:{ios:"keplrwallet://",android:"intent://"}},walletType:"wc_keplr_mobile",formatNativeUrl:(s,i,a)=>{let c=s.replaceAll("/","").replaceAll(":",""),l=encodeURIComponent(i);switch(a){case"ios":return `${c}://wcV2?${l}`;case"android":return `${c}://wcV2?${l}#Intent;package=com.chainapsis.keplr;scheme=keplrwallet;end;`;default:return `${c}://wc?uri=${l}`}}};return ue(e)};h();var En=()=>{var n,o,r;if(!((r=(o=(n=p.getState().walletConnect)==null?void 0:n.options)==null?void 0:o.projectId)!=null&&r.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!le())throw new Error("WalletConnect Leap mobile is only supported in mobile");let e={encoding:"base64",appUrl:{mobile:{ios:"leapcosmos://",android:"intent://"}},walletType:"wc_leap_mobile",formatNativeUrl:(s,i,a)=>{let c=s.replaceAll("/","").replaceAll(":",""),l=encodeURIComponent(i);switch(a){case"ios":return `${c}://wcV2?${l}`;case"android":return `${c}://wcV2?${l}#Intent;package=io.leapwallet.cosmos;scheme=leapwallet;end;`;default:return `${c}://wc?uri=${l}`}}};return ue(e)};h();var Pt=()=>{var e;if(typeof((e=window.xfi)==null?void 0:e.keplr)!="undefined"){let n=window.xfi.keplr;return Object.assign(n,{subscription:s=>{let i=()=>{Z(),s();};return window.addEventListener("keplr_keystorechange",i),()=>{window.removeEventListener("keplr_keystorechange",i);}}})}throw p.getState()._notFoundFn(),new Error("window.xfi.keplr is not defined")};var te=(e=p.getState().walletType)=>{try{return Q(e),!0}catch(n){return !1}},Z=()=>{window.sessionStorage.removeItem(me),w.setState(Se);},Q=(e=p.getState().walletType)=>{var r;let n=(()=>{switch(e){case"keplr":return xt();case"leap":return Tt();case"cosmostation":return Et();case"vectis":return Mt();case"walletconnect":return ue();case"wc_keplr_mobile":return bn();case"wc_leap_mobile":return En();case"wc_cosmostation_mobile":return In();case"wc_clot_mobile":return An();case"metamask_snap_leap":return Sn();case"metamask_snap_cosmos":return mn();case"station":return kt();case"xdefi":return Pt();case"capsule":return At();case"cosmiframe":return bt();case"compass":return It();case"initia":return yn();case"okx":return Ot();default:throw new Error("Unknown wallet type")}})(),o=p.getState().walletDefaultOptions;return o&&((r=n.setDefaultOptions)==null||r.call(n,o)),n},ks=()=>p.getState().walletType,Ms=()=>Object.fromEntries(on.map(e=>[e,te(e)])),qt=e=>e==="capsule",xn=e=>e==="walletconnect"||e==="wc_keplr_mobile"||e==="wc_leap_mobile"||e==="wc_cosmostation_mobile",ie=e=>u(void 0,null,function*(){let n=Buffer.from(e),r=`0x${(0, On.keccak256)(n).slice(-40)}`;return Mi(r)}),Mi=e=>{let n=ki.createHash("sha3-256").update(e.slice(2).toLowerCase()).digest("hex"),o="0x";for(let r=0;r<e.slice(2).length;r++){let s=n.at(r),i=n.at(r+2);if(s===void 0||i===void 0)return e;o+=parseInt(s,16)>7?i.toUpperCase():i.toLowerCase();}return o};var ye=e=>u(void 0,null,function*(){var n;try{let{recentChainIds:o,chains:r,walletType:s}=p.getState(),i=(e==null?void 0:e.walletType)||s;if(!te(i))throw new Error(`${i} is not available`);let c=Q(i),l=typeof(e==null?void 0:e.chainId)=="string"?[e.chainId]:(e==null?void 0:e.chainId)||o;if(!l)throw new Error("No last known connected chain, connect action requires chain ids");let f=r==null?void 0:r.map(A=>A.chainId);l.forEach(A=>{if(!(f!=null&&f.includes(A)))throw new Error(`Chain ${A} is not provided in GrazProvider`)}),w.setState(A=>{let y=p.getState()._reconnect||!!p.getState()._reconnectConnector||!!l;return A.activeChainIds&&l.filter(b=>{var D;return !((D=A.activeChainIds)!=null&&D.includes(b))}).length>0?{status:"connecting"}:y?{status:"reconnecting"}:{status:"connecting"}});let{accounts:T}=w.getState();if(yield (n=c.init)==null?void 0:n.call(c),qt(i)&&w.getState().capsuleClient&&Object.values(w.getState().accounts||[]).length>0){let A=l.map(b=>r.find(D=>D.chainId===b)),y=w.getState().accounts;w.setState({status:"connecting"});let I=Object.fromEntries(yield Promise.all(l.map(b=>u(void 0,null,function*(){return [b,yield c.getKey(b)]}))));return w.setState(b=>({accounts:F(F({},b.accounts||{}),I)})),p.setState(b=>({recentChainIds:[...b.recentChainIds||[],...l].filter((D,g,x)=>x.indexOf(D)===g)})),w.setState(b=>({activeChainIds:[...b.activeChainIds||[],...l].filter((D,g,x)=>x.indexOf(D)===g)})),w.setState({status:"connected"}),{accounts:y,walletType:i,chains:A}}if(yield c.enable(l),qt(i)){let A=l.map(I=>r.find(b=>b.chainId===I)),y=w.getState().accounts;return w.setState({status:"connecting"}),{accounts:y,walletType:i,chains:A}}if(!xn(i)){let A=Object.fromEntries(yield Promise.all(l.map(y=>u(void 0,null,function*(){return [y,yield c.getKey(y)]}))));w.setState(y=>({accounts:F(F({},y.accounts||{}),A)}));}p.setState(A=>({recentChainIds:[...A.recentChainIds||[],...l].filter((y,I,b)=>b.indexOf(y)===I)})),w.setState(A=>({activeChainIds:[...A.activeChainIds||[],...l].filter((y,I,b)=>b.indexOf(y)===I)})),p.setState({walletType:i,_reconnect:!!(e!=null&&e.autoReconnect),_reconnectConnector:i}),w.setState({status:"connected"}),typeof window!="undefined"&&window.sessionStorage.setItem(me,"Active");let C=l.map(A=>r.find(y=>y.chainId===A));return {accounts:w.getState().accounts,walletType:i,chains:C}}catch(o){throw console.error("connect ",o),w.getState().accounts===null&&w.setState({status:"disconnected"}),w.getState().accounts&&w.getState().activeChainIds&&w.setState({status:"connected"}),o}}),Ce=e=>{typeof window!="undefined"&&window.sessionStorage.removeItem(me);let n=typeof(e==null?void 0:e.chainId)=="string"?[e.chainId]:e==null?void 0:e.chainId;if(n){let o=w.getState().accounts;n.forEach(s=>{o==null||delete o[s];}),Object.values(o||{}).length===0?(w.setState(Se),p.setState({_reconnect:!1,_reconnectConnector:null,recentChainIds:null})):(w.setState(s=>{var i;return {activeChainIds:(i=s.activeChainIds)==null?void 0:i.filter(a=>!n.includes(a)),accounts:o}}),p.setState(s=>{var i;return {recentChainIds:(i=s.recentChainIds)==null?void 0:i.filter(a=>!n.includes(a))}}));}else w.setState(Se),p.setState({_reconnect:!1,_reconnectConnector:null,recentChainIds:null});return Promise.resolve()},oe=e=>u(void 0,null,function*(){var s;let{recentChainIds:n,_reconnectConnector:o,_reconnect:r}=p.getState();try{let i=te(o||void 0);if(n&&i&&o)return yield ye({chainId:n,walletType:o,autoReconnect:r})}catch(i){(s=e==null?void 0:e.onError)==null||s.call(e,i),Ce();}}),Tn=e=>u(void 0,null,function*(){if(!(e!=null&&e.chainId))throw new Error("chainId is required");let{walletType:n}=p.getState(),o=e.walletType||n;if(!te(o))throw new Error(`${o} is not available`);let s=Q(o),i=s.getOfflineSigner(e.chainId),a=s.getOfflineSignerOnlyAmino(e.chainId),c=yield s.getOfflineSignerAuto(e.chainId);return {offlineSigner:i,offlineSignerAmino:a,offlineSignerAuto:c}});h();var zt=()=>{p.setState({recentChainIds:null});},qs=()=>p.getState().recentChainIds,zs=()=>{var o;let{recentChainIds:e,chains:n}=p.getState();return (o=e==null?void 0:e.map(r=>n.find(s=>s.chainId===r)))!=null?o:null},Hs=({chainId:e})=>{var n;return (n=p.getState().chains)==null?void 0:n.find(o=>o.chainId===e)},Qs=({chainId:e})=>{var n;return (n=p.getState().chains)==null?void 0:n.filter(o=>e==null?void 0:e.includes(o.chainId))},Ht=o=>u(void 0,[o],function*({chainInfo:e,walletType:n}){let r=Q(n);return n==="capsule"?yield ye({chainId:e.chainId,walletType:n}):yield r.experimentalSuggestChain(e),e}),vn=e=>u(void 0,null,function*(){var r;let n=p.getState().walletType;return yield Ht({chainInfo:e.chainInfo,walletType:(r=e.walletType)!=null?r:n}),yield ye({chainId:e.chainInfo.chainId,walletType:e.walletType,autoReconnect:e.autoReconnect})});h();var kn=e=>(p.setState(n=>({iframeOptions:e.iframeOptions||n.iframeOptions,walletConnect:e.walletConnect||n.walletConnect,walletType:e.defaultWallet||n.walletType,capsuleConfig:e.capsuleConfig||n.capsuleConfig,walletDefaultOptions:e.walletDefaultOptions||n.walletDefaultOptions,chains:e.chains,chainsConfig:e.chainsConfig||n.chainsConfig,multiChainFetchConcurrency:e.multiChainFetchConcurrency||n.multiChainFetchConcurrency,_notFoundFn:e.onNotFound||n._notFoundFn,_onReconnectFailed:e.onReconnectFailed||n._onReconnectFailed,_reconnect:e.autoReconnect===void 0?!0:e.autoReconnect||n._reconnect})),e);h();var Mn=a=>u(void 0,[a],function*({signingClient:e,senderAddress:n,recipientAddress:o,amount:r,fee:s,memo:i}){if(!e)throw new Error("No connected account detected");if(!n)throw new Error("senderAddress is not defined");return e.sendTokens(n,o,r,s,i)}),Pn=T=>u(void 0,[T],function*({signingClient:e,senderAddress:n,recipientAddress:o,transferAmount:r,sourcePort:s,sourceChannel:i,timeoutHeight:a,timeoutTimestamp:c,fee:l,memo:f}){if(!e)throw new Error("Stargate signing client is not ready");if(!n)throw new Error("senderAddress is not defined");return e.sendIbcTokens(n,o,r,s,i,a,c,l,f)}),Wn=c=>u(void 0,[c],function*({signingClient:e,senderAddress:n,msg:o,fee:r,options:s,label:i,codeId:a}){if(!e)throw new Error("CosmWasm signing client is not ready");return e.instantiate(n,a,o,i,r,s)}),_n=c=>u(void 0,[c],function*({signingClient:e,senderAddress:n,msg:o,fee:r,contractAddress:s,funds:i,memo:a}){if(!e)throw new Error("CosmWasm signing client is not ready");return e.execute(n,s,o,r,a,i)}),Rn=(e,n,o)=>u(void 0,null,function*(){if(!o)throw new Error("CosmWasm client is not ready");return yield o.queryContractSmart(e,n)}),Dn=(e,n,o)=>{if(!o)throw new Error("CosmWasm client is not ready");let r=new TextEncoder().encode(n);return o.queryContractRaw(e,r)};h();var na=e=>e,ia=e=>e;h();h();var Wt=e=>e?Object.keys(e).length===0:!0;h();h();var Qt=class extends Error{constructor(n){super(),this.name="AbortError",this.message=n;}},Kn=e=>globalThis.DOMException===void 0?new Qt(e):new DOMException(e),Bn=e=>{let n=e.reason===void 0?Kn("This operation was aborted."):e.reason;return n instanceof Error?n:Kn(n)};function jt(i,a){return u(this,arguments,function*(e,n,{concurrency:o=Number.POSITIVE_INFINITY,stopOnError:r=!0,signal:s}={}){return new Promise((c,l)=>{if(e[Symbol.iterator]===void 0&&e[Symbol.asyncIterator]===void 0)throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof e})`);if(typeof n!="function")throw new TypeError("Mapper function is required");if(!((Number.isSafeInteger(o)||o===Number.POSITIVE_INFINITY)&&o>=1))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${o}\` (${typeof o})`);let f=[],T=[],C=new Map,E=!1,A=!1,y=!1,I=0,b=0,D=e[Symbol.iterator]===void 0?e[Symbol.asyncIterator]():e[Symbol.iterator](),g=R=>{E=!0,A=!0,l(R);};s&&(s.aborted&&g(Bn(s)),s.addEventListener("abort",()=>{g(Bn(s));}));let x=()=>u(this,null,function*(){if(A)return;let R=yield D.next(),q=b;if(b++,R.done){if(y=!0,I===0&&!A){if(!r&&T.length>0){g(new AggregateError(T));return}if(A=!0,C.size===0){c(f);return}let z=[];for(let[j,ae]of f.entries())C.get(j)!==Nn&&z.push(ae);c(z);}return}I++,u(this,null,function*(){try{let z=yield R.value;if(A)return;let j=yield n(z,q);j===Nn&&C.set(q,j),f[q]=j,I--,yield x();}catch(z){if(r)g(z);else {T.push(z),I--;try{yield x();}catch(j){g(j);}}}});});u(this,null,function*(){for(let R=0;R<o;R++){try{yield x();}catch(q){g(q);break}if(y||E)break}});})})}var Nn=Symbol("skip");var re=({chainId:e,multiChain:n})=>{let o=p(s=>s.chains);if(!o)throw new Error("No chains found in GrazProvider");let r=typeof e=="string"?[e]:e;switch(!0){case(!!n&&!!r):return r.map(s=>o.find(i=>i.chainId===s)).filter(Boolean);case(!n&&!!r):return [r.map(s=>o.find(i=>i.chainId===s)).filter(Boolean)[0]];case(!!n&&!r):return o;default:return [o[0]]}},se=(e,n,o)=>u(void 0,null,function*(){let r=p.getState().multiChainFetchConcurrency;if(e){let i=yield jt(n,o,{concurrency:r});return Object.fromEntries(i.map((a,c)=>[n[c].chainId,a]))}return yield o(n[0])}),Fn=(e,n,o)=>{if(e){let s=n.map(o);return Object.fromEntries(s.map((i,a)=>[n[a].chainId,i]))}return o(n[0])};h();var Yt=e=>{let n=re({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),o=useMemo(()=>["USE_STARGATE_CLIENT",n],[n]);return useQuery({queryKey:o,queryFn:s=>u(void 0,[s],function*({queryKey:[,r]}){if(r.length<1)throw new Error("No chains found");return yield se(!!(e!=null&&e.multiChain),r,a=>u(void 0,null,function*(){var T;let c=(T=p.getState().chainsConfig)==null?void 0:T[a.chainId],l={url:a.rpc,headers:F({},(c==null?void 0:c.rpcHeaders)||{})};return yield StargateClient.connect(l)}))}),enabled:!!n&&n.length>0&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})},Xt=e=>{let n=re({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),o=useMemo(()=>["USE_COSMWASM_CLIENT",n],[n]);return useQuery({queryKey:o,queryFn:s=>u(void 0,[s],function*({queryKey:[,r]}){if(r.length<1)throw new Error("No chains found");return yield se(!!(e!=null&&e.multiChain),r,a=>u(void 0,null,function*(){var T;let c=(T=p.getState().chainsConfig)==null?void 0:T[a.chainId],l={url:a.rpc,headers:F({},(c==null?void 0:c.rpcHeaders)||{})};return yield CosmWasmClient.connect(l)}))}),enabled:!!n&&n.length>0&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})},_t=({type:e,chainId:n,multiChain:o,enabled:r})=>{let s=re({chainId:n,multiChain:o}),i=useMemo(()=>["USE_TENDERMINT_CLIENT",e,s],[e,s]);return useQuery({queryKey:i,queryFn:l=>u(void 0,[l],function*({queryKey:[,a,c]}){if(c.length<1)throw new Error("No chains found");return yield se(!!o,c,T=>u(void 0,null,function*(){var I;let C=(I=p.getState().chainsConfig)==null?void 0:I[T.chainId],E={url:T.rpc,headers:F({},(C==null?void 0:C.rpcHeaders)||{})};return yield (a==="tm37"?Tendermint37Client:Tendermint34Client).connect(E)}))}),enabled:!!s&&s.length>0&&(r!==void 0?!!r:!0),refetchOnWindowFocus:!1})};h();var Ma=()=>p(e=>({walletType:e.walletType,isCosmostation:e.walletType==="cosmostation",isCosmostationMobile:e.walletType==="wc_cosmostation_mobile",isKeplr:e.walletType==="keplr",isKeplrMobile:e.walletType==="wc_keplr_mobile",isLeap:e.walletType==="leap",isLeapMobile:e.walletType==="wc_leap_mobile",isVectis:e.walletType==="vectis",isWalletConnect:e.walletType==="walletconnect",isMetamaskSnapLeap:e.walletType==="metamask_snap_leap",isStation:e.walletType==="station",isCapsule:e.walletType==="capsule",isCosmiframe:e.walletType==="cosmiframe"}),shallow),Rt=e=>{let o=["USE_CHECK_WALLET",p(s=>e||s.walletType)];return useQuery({queryKey:o,queryFn:({queryKey:[,s]})=>te(s)})};var he=e=>{let n=p(c=>c.walletType),o=w(c=>c.activeChainIds),r=re({chainId:e!=null&&e.chainId?e.chainId:o||void 0,multiChain:e==null?void 0:e.multiChain}),s=w(c=>c.accounts),i=w(c=>c.status);return useEffect(()=>w.subscribe(c=>c.status,(c,l)=>{var f,T,C;if(c==="connected"){let{accounts:E,activeChainIds:A}=w.getState(),{chains:y}=p.getState(),{walletType:I}=p.getState();if(!E||!A||!y)return (f=e==null?void 0:e.onDisconnect)==null?void 0:f.call(e);(T=e==null?void 0:e.onConnect)==null||T.call(e,{accounts:E,chains:A.map(b=>y.find(D=>D.chainId===b)),walletType:I,isReconnect:l==="reconnecting"});}c==="disconnected"&&((C=e==null?void 0:e.onDisconnect)==null||C.call(e));}),[e]),{data:useMemo(()=>s?Fn(!!(e!=null&&e.multiChain),r,c=>s[c.chainId]):void 0,[s,r,e==null?void 0:e.multiChain]),isConnected:i==="connected",isConnecting:i==="connecting",isDisconnected:i==="disconnected",isReconnecting:i==="reconnecting",isLoading:i==="connecting"||i==="reconnecting",walletType:i==="connected"?n:void 0,reconnect:oe,status:i}},Ni=e=>{let n=re({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),{data:o}=he(),r=(e==null?void 0:e.bech32Address)||(o==null?void 0:o.bech32Address),{data:s}=Yt({chainId:n.map(a=>a.chainId),multiChain:!0,enabled:((e==null?void 0:e.enabled)===void 0?!0:e.enabled)&&!!r}),i=useMemo(()=>["USE_ALL_BALANCES",s,n,r,e==null?void 0:e.chainId],[r,e==null?void 0:e.chainId,n,s]);return useQuery({queryKey:i,queryFn:f=>u(void 0,[f],function*({queryKey:[,a,c,l]}){if(!l)throw new Error("address is not defined");return yield se(!!(e!=null&&e.multiChain),c,C=>u(void 0,null,function*(){let E=a==null?void 0:a[C.chainId];if(!E)throw new Error(`Client is not ready ${C.chainId}`);if(!C.bech32Config)throw new Error("Chain is missing bech32 config");return yield E.getAllBalances(toBech32(C.bech32Config.bech32PrefixAccAddr,fromBech32(l).data))}))}),enabled:!!r&&!!n&&n.length>0&&!Wt(s)&&((e==null?void 0:e.enabled)===void 0?!0:e.enabled),refetchOnMount:!1,refetchOnReconnect:!0,refetchOnWindowFocus:!1})},qa=e=>{let n=re({chainId:e.chainId}),{data:o}=he({chainId:e.chainId}),r=e.bech32Address||(o==null?void 0:o.bech32Address),{data:s,refetch:i}=Ni({chainId:n.map(l=>l.chainId),bech32Address:r,enabled:!!r&&(e.enabled===void 0?!0:e.enabled)}),a=["USE_BALANCE",e.denom,s,n,r,e.chainId],c=useQuery({queryKey:a,queryFn:({queryKey:[,l,f]})=>f==null?void 0:f.find(T=>T.denom===l),enabled:!!e.denom&&!!s&&!!(s!=null&&s.length)&&(e.enabled===void 0?!0:e.enabled)});return J(F({},c),{refetch:l=>u(void 0,null,function*(){return yield i(),c.refetch(l)})})},za=({onError:e,onLoading:n,onSuccess:o}={})=>{let s=useMutation({mutationKey:["USE_CONNECT",e,n,o],mutationFn:ye,onError:(a,c)=>e==null?void 0:e(a,c),onMutate:n,onSuccess:a=>Promise.resolve(o==null?void 0:o(a))}),{data:i}=Rt();return {connect:a=>s.mutate(a),connectAsync:a=>s.mutateAsync(a),error:s.error,isLoading:s.isPending,isSuccess:s.isSuccess,isSupported:!!i,status:s.status}},Ha=({onError:e,onLoading:n,onSuccess:o}={})=>{let s=useMutation({mutationKey:["USE_DISCONNECT",e,n,o],mutationFn:Ce,onError:i=>Promise.resolve(e==null?void 0:e(i,void 0)),onMutate:n,onSuccess:()=>Promise.resolve(o==null?void 0:o(void 0))});return {disconnect:i=>s.mutate(i),disconnectAsync:i=>s.mutateAsync(i),error:s.error,isLoading:s.isPending,isSuccess:s.isSuccess,status:s.status}},Qa=e=>{let n=re({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),o=p(s=>s.walletType),r=useMemo(()=>["USE_OFFLINE_SIGNERS",n,o],[n,o]);return useQuery({queryKey:r,queryFn:a=>u(void 0,[a],function*({queryKey:[,s,i]}){if(s.length<1)throw new Error("No chain found");if(!te(i))throw new Error(`${i} is not available`);return yield se(!!(e!=null&&e.multiChain),s,f=>u(void 0,null,function*(){return yield Tn({chainId:f.chainId,walletType:i})}))}),enabled:!!n&&n.length>0&&!!o,refetchOnWindowFocus:!1})},ja=e=>{let n=re({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),{data:o}=he(),{data:r}=Yt({chainId:n.map(a=>a.chainId),multiChain:!0}),s=(e==null?void 0:e.bech32Address)||(o==null?void 0:o.bech32Address),i=useMemo(()=>["USE_BALANCE_STAKED",r,n,s],[n,s,r]);return useQuery({queryKey:i,queryFn:f=>u(void 0,[f],function*({queryKey:[,a,c,l]}){if(!l)throw new Error("address is not defined");return yield se(!!(e!=null&&e.multiChain),c,C=>u(void 0,null,function*(){var A;if(!a)throw new Error("Client is not ready");if(!C.bech32Config)throw new Error("Chain is missing bech32 config");return yield (A=a[C.chainId])==null?void 0:A.getBalanceStaked(toBech32(C.bech32Config.bech32PrefixAccAddr,fromBech32(l).data))}))}),enabled:!!s&&!!n&&n.length>0&&!!r,refetchOnMount:!1,refetchOnReconnect:!0,refetchOnWindowFocus:!1})};h();var ec=()=>{let e=p(r=>r.capsuleState),n=w(r=>r.capsuleClient),o=At();return {setModalState:r=>{p.setState(s=>{var i;return {capsuleState:{showModal:r,chainId:(i=s.capsuleState)==null?void 0:i.chainId}}});},modalState:!!(e!=null&&e.showModal),client:n,onAfterLoginSuccessful:o.onAfterLoginSuccessful,onLoginFailure:()=>{Ce();}}};h();var ac=()=>w(e=>e.activeChainIds),Fi=()=>{var e;return (e=w(n=>n.activeChainIds))==null?void 0:e.map(n=>{var r;let o=(r=p.getState().chains)==null?void 0:r.find(s=>s.chainId===n);if(o)return o}).filter(Boolean)},cc=({chainId:e})=>{var n;return (n=p().chains)==null?void 0:n.find(o=>o.chainId===e)},lc=({chainId:e})=>{var n;return (n=p().chains)==null?void 0:n.filter(o=>e==null?void 0:e.includes(o.chainId))},uc=({denom:e})=>{let n=Fi();return useQuery({queryKey:["USE_ACTIVE_CHAIN_CURRENCY",e],queryFn:({queryKey:[,s]})=>{var i;return (i=n==null?void 0:n.find(a=>a.currencies.find(c=>c.coinMinimalDenom===s)))==null?void 0:i.currencies.find(a=>a)}})},pc=e=>{var s;let n=(s=e.status)!=null?s:"BOND_STATUS_BONDED",o=["USE_ACTIVE_CHAIN_VALIDATORS",e.queryClient,n];return useQuery({queryKey:o,queryFn:c=>u(void 0,[c],function*({queryKey:[,i,a]}){if(!i)throw new Error("Query client is not defined");return yield i.staking.validators(a)}),enabled:typeof e.queryClient!="undefined"})},dc=()=>({data:p(n=>n.recentChainIds),clear:zt}),fc=()=>{var n;return {data:(n=p(o=>o.recentChainIds))==null?void 0:n.map(o=>{var s;let r=(s=p.getState().chains)==null?void 0:s.find(i=>i.chainId===o);if(r)return r}).filter(Boolean),clear:zt}},mc=({onError:e,onLoading:n,onSuccess:o}={})=>{let s=useMutation({mutationKey:["USE_SUGGEST_CHAIN",e,n,o],mutationFn:Ht,onError:(i,a)=>Promise.resolve(e==null?void 0:e(i,a.chainInfo)),onMutate:i=>n==null?void 0:n(i.chainInfo),onSuccess:i=>Promise.resolve(o==null?void 0:o(i))});return {error:s.error,isLoading:s.isPending,isSuccess:s.isSuccess,suggest:s.mutate,suggestAsync:s.mutateAsync,status:s.status}},gc=({onError:e,onLoading:n,onSuccess:o}={})=>{let s=useMutation({mutationKey:["USE_SUGGEST_CHAIN_AND_CONNECT",e,n,o],mutationFn:vn,onError:(a,c)=>Promise.resolve(e==null?void 0:e(a,c)),onMutate:a=>n==null?void 0:n(a),onSuccess:a=>Promise.resolve(o==null?void 0:o(a))}),{data:i}=Rt();return {error:s.error,isLoading:s.isPending,isSuccess:s.isSuccess,isSupported:!!i,status:s.status,suggestAndConnect:s.mutate,suggestAndConnectAsync:s.mutateAsync}};h();var bc=({onError:e,onLoading:n,onSuccess:o}={})=>{let{data:r}=he(),s=r==null?void 0:r.bech32Address,i=useMutation({mutationKey:["USE_SEND_TOKENS",e,n,o,s],mutationFn:a=>Mn(F({senderAddress:s},a)),onError:(a,c)=>Promise.resolve(e==null?void 0:e(a,c)),onMutate:n,onSuccess:a=>Promise.resolve(o==null?void 0:o(a))});return {error:i.error,isLoading:i.isPending,isSuccess:i.isSuccess,sendTokens:i.mutate,sendTokensAsync:i.mutateAsync,status:i.status}},Ec=({onError:e,onLoading:n,onSuccess:o}={})=>{let{data:r}=he(),s=r==null?void 0:r.bech32Address,i=useMutation({mutationKey:["USE_SEND_IBC_TOKENS",e,n,o,s],mutationFn:a=>Pn(F({senderAddress:s},a)),onError:(a,c)=>Promise.resolve(e==null?void 0:e(a,c)),onMutate:n,onSuccess:a=>Promise.resolve(o==null?void 0:o(a))});return {error:i.error,isLoading:i.isPending,isSuccess:i.isSuccess,sendIbcTokens:i.mutate,sendIbcTokensAsync:i.mutateAsync,status:i.status}},Oc=({codeId:e,onError:n,onLoading:o,onSuccess:r})=>{let{data:s}=he(),i=s==null?void 0:s.bech32Address,c=useMutation({mutationKey:["USE_INSTANTIATE_CONTRACT",n,o,r,e,i],mutationFn:l=>{var T;if(!i)throw new Error("senderAddress is undefined");let f=J(F({},l),{fee:(T=l.fee)!=null?T:"auto",senderAddress:i,codeId:e});return Wn(f)},onError:(l,f)=>Promise.resolve(n==null?void 0:n(l,f)),onMutate:o,onSuccess:l=>Promise.resolve(r==null?void 0:r(l))});return {error:c.error,isLoading:c.isPending,isSuccess:c.isSuccess,instantiateContract:c.mutate,instantiateContractAsync:c.mutateAsync,status:c.status}},xc=({contractAddress:e,onError:n,onLoading:o,onSuccess:r})=>{let{data:s}=he(),i=s==null?void 0:s.bech32Address,c=useMutation({mutationKey:["USE_EXECUTE_CONTRACT",n,o,r,e,i],mutationFn:l=>{var T,C,E;if(!i)throw new Error("senderAddress is undefined");let f=J(F({},l),{fee:(T=l.fee)!=null?T:"auto",senderAddress:i,contractAddress:e,memo:(C=l.memo)!=null?C:"",funds:(E=l.funds)!=null?E:[]});return _n(f)},onError:(l,f)=>Promise.resolve(n==null?void 0:n(l,f)),onMutate:o,onSuccess:l=>Promise.resolve(r==null?void 0:r(l))});return {error:c.error,isLoading:c.isPending,isSuccess:c.isSuccess,executeContract:c.mutate,executeContractAsync:c.mutateAsync,status:c.status}},Tc=e=>{let{data:n}=Xt();return useQuery({queryKey:["USE_QUERY_SMART",e==null?void 0:e.address,e==null?void 0:e.queryMsg,n],queryFn:({queryKey:[,r]})=>{if(!(e!=null&&e.address)||!e.queryMsg)throw new Error("address or queryMsg undefined");return Rn(e.address,e.queryMsg,n)},enabled:!!(e!=null&&e.address)&&!!(e!=null&&e.queryMsg)&&!!n})},vc=e=>{let{data:n}=Xt(),o=["USE_QUERY_RAW",e==null?void 0:e.key,e==null?void 0:e.address,n];return useQuery({queryKey:o,queryFn:({queryKey:[,s]})=>{if(!(e!=null&&e.address)||!e.key)throw new Error("address or key undefined");return Dn(e.address,e.key,n)},enabled:!!(e!=null&&e.address)&&!!(e!=null&&e.key)&&!!n})};h();function Uc(e){let n=re({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),o=p(i=>i.walletType),r=w(i=>i.activeChainIds),s=useMemo(()=>["USE_STARGATE_SIGNING_CLIENT",n,o,e,r],[r,e,n,o]);return useQuery({queryKey:s,queryFn:c=>u(this,[c],function*({queryKey:[,i,a]}){if(i.length<1)throw new Error("No chains found");return yield se(!!(e!=null&&e.multiChain),i,f=>u(this,null,function*(){var I,b;if(!(r!=null&&r.includes(f.chainId)))return null;if(!te(a))throw new Error(`${a} is not available`);let C=yield (()=>u(this,null,function*(){switch(e==null?void 0:e.offlineSigner){case"offlineSigner":return Q(a).getOfflineSigner(f.chainId);case"offlineSignerAuto":return Q(a).getOfflineSignerAuto(f.chainId);case"offlineSignerOnlyAmino":return Q(a).getOfflineSignerOnlyAmino(f.chainId);default:return Q(a).getOfflineSignerAuto(f.chainId)}}))(),E=(I=p.getState().chainsConfig)==null?void 0:I[f.chainId],A={url:f.rpc,headers:F({},(E==null?void 0:E.rpcHeaders)||{})};return (e==null?void 0:e.multiChain)===!0&&e.opts,yield SigningStargateClient.connectWithSigner(A,C,e!=null&&e.multiChain?(b=e.opts)==null?void 0:b[f.chainId]:e==null?void 0:e.opts)}))}),enabled:!!n&&n.length>0&&!!o&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}function Gc(e){let n=re({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),o=p(i=>i.walletType),r=w(i=>i.activeChainIds),s=useMemo(()=>["USE_COSMWASM_SIGNING_CLIENT",n,o,e,r],[r,e,n,o]);return useQuery({queryKey:s,queryFn:c=>u(this,[c],function*({queryKey:[,i,a]}){if(i.length<1)throw new Error("No chains found");return yield se(!!(e!=null&&e.multiChain),i,f=>u(this,null,function*(){var b,D;if(!(r!=null&&r.includes(f.chainId)))return null;if(!te(a))throw new Error(`${a} is not available`);let C=yield (()=>u(this,null,function*(){switch(e==null?void 0:e.offlineSigner){case"offlineSigner":return Q(a).getOfflineSigner(f.chainId);case"offlineSignerAuto":return Q(a).getOfflineSignerAuto(f.chainId);case"offlineSignerOnlyAmino":return Q(a).getOfflineSignerOnlyAmino(f.chainId);default:return Q(a).getOfflineSignerAuto(f.chainId)}}))(),E=(b=p.getState().chainsConfig)==null?void 0:b[f.chainId],A={url:f.rpc,headers:F({},(E==null?void 0:E.rpcHeaders)||{})},y=E!=null&&E.gas?GasPrice.fromString(`${E.gas.price}${E.gas.denom}`):void 0;return yield SigningCosmWasmClient.connectWithSigner(A,C,F({gasPrice:y},e!=null&&e.multiChain?(D=e.opts)==null?void 0:D[f.chainId]:(e==null?void 0:e.opts)||{}))}))}),enabled:!!n&&n.length>0&&!!o&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}function qc(e){let n=re({chainId:e.chainId,multiChain:e.multiChain}),o=p(a=>a.walletType),r=w(a=>a.activeChainIds),s=useMemo(()=>["USE_STARGATE_TM_SIGNING_CLIENT",n,o,e,r],[r,e,n,o]),{data:i}=_t({type:e.type,chainId:e.chainId,multiChain:e.multiChain});return useQuery({queryKey:s,queryFn:l=>u(this,[l],function*({queryKey:[,a,c]}){if(a.length<1)throw new Error("No chains found");return yield se(!!e.multiChain,a,T=>u(this,null,function*(){var I;if(!(r!=null&&r.includes(T.chainId)))return null;if(!te(c))throw new Error(`${c} is not available`);if(!i)throw new Error("No tendermint client found");let E=yield (()=>u(this,null,function*(){switch(e.offlineSigner){case"offlineSigner":return Q(c).getOfflineSigner(T.chainId);case"offlineSignerAuto":return Q(c).getOfflineSignerAuto(T.chainId);case"offlineSignerOnlyAmino":return Q(c).getOfflineSignerOnlyAmino(T.chainId);default:return Q(c).getOfflineSignerAuto(T.chainId)}}))(),A=e.multiChain?i[T.chainId]:i;return yield SigningStargateClient.createWithSigner(A,E,e.multiChain?(I=e.opts)==null?void 0:I[T.chainId]:e.opts)}))}),enabled:!!n&&n.length>0&&!!o&&!!i&&(e.enabled!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}function zc(e){let n=re({chainId:e.chainId,multiChain:e.multiChain}),o=p(c=>c.walletType),r=w(c=>c.activeChainIds),s=useMemo(()=>["USE_COSMWASM_TM_SIGNING_CLIENT",n,o,e,r],[r,e,n,o]),{data:i}=_t({type:e.type,chainId:e.chainId,multiChain:!1,enabled:!e.multiChain}),{data:a}=_t({type:e.type,chainId:e.chainId,multiChain:!0,enabled:!!e.multiChain});return useQuery({queryKey:s,queryFn:f=>u(this,[f],function*({queryKey:[,c,l]}){if(c.length<1)throw new Error("No chains found");return yield se(!!e.multiChain,c,C=>u(this,null,function*(){var g,x;if(!(r!=null&&r.includes(C.chainId)))return null;if(!te(l))throw new Error(`${l} is not available`);let A=yield (()=>u(this,null,function*(){switch(e.offlineSigner){case"offlineSigner":return Q(l).getOfflineSigner(C.chainId);case"offlineSignerAuto":return Q(l).getOfflineSignerAuto(C.chainId);case"offlineSignerOnlyAmino":return Q(l).getOfflineSignerOnlyAmino(C.chainId);default:return Q(l).getOfflineSignerAuto(C.chainId)}}))(),y=(g=p.getState().chainsConfig)==null?void 0:g[C.chainId],I=y!=null&&y.gas?GasPrice.fromString(`${y.gas.price}${y.gas.denom}`):void 0,b=e.multiChain?a==null?void 0:a[C.chainId]:i;if(!b)throw new Error("No tendermint client found");return yield SigningCosmWasmClient.createWithSigner(b,A,F({gasPrice:I},e.multiChain?(x=e.opts)==null?void 0:x[C.chainId]:e.opts||{}))}))}),enabled:!!n&&n.length>0&&!!o&&(!!i||!Wt(a))&&(e.enabled!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}h();h();var Vn=({children:e})=>{let[n,o]=useState(!1);return useEffect(()=>{o(!0);},[]),jsx(Fragment,{children:n?e:null})};h();var Hi=()=>{let e=typeof window!="undefined"&&window.sessionStorage.getItem(me)==="Active",{_reconnect:n,_onReconnectFailed:o,_reconnectConnector:r,iframeOptions:s,chains:i}=p(),{activeChainIds:a,wcSignClients:c}=w(),l=te(r||void 0);return useEffect(()=>{if(!s||s.autoConnect===!1||!s.allowedIframeParentOrigins.length||!i)return;new Cosmiframe(s.allowedIframeParentOrigins).isReady().then(T=>{if(T)return ye({chainId:i.map(C=>C.chainId),walletType:"cosmiframe"})});},[s]),useEffect(()=>{if(r){if(!l)return;e&&a?oe({onError:o}):!e&&n&&oe({onError:o});}},[l]),useEffect(()=>{var f,T,C,E,A,y,I,b,D,g,x,R,q,z,j,ae,ge,O,v,M;if(r){if(!l)return;r==="cosmostation"&&((T=(f=Et()).subscription)==null||T.call(f,()=>{oe({onError:o});})),r==="keplr"&&((E=(C=xt()).subscription)==null||E.call(C,()=>{oe({onError:o});})),r==="leap"&&((y=(A=Tt()).subscription)==null||y.call(A,()=>{oe({onError:o});})),r==="compass"&&((b=(I=It()).subscription)==null||b.call(I,()=>{oe({onError:o});})),r==="vectis"&&((g=(D=Mt()).subscription)==null||g.call(D,()=>{oe({onError:o});})),r==="walletconnect"&&c.has("walletconnect")&&((R=(x=ue()).subscription)==null||R.call(x,()=>{oe({onError:o});})),r==="station"&&((z=(q=kt()).subscription)==null||z.call(q,()=>{oe({onError:o});})),r==="xdefi"&&((ae=(j=Pt()).subscription)==null||ae.call(j,()=>{oe({onError:o});})),r==="cosmiframe"&&((O=(ge=bt()).subscription)==null||O.call(ge,()=>{oe({onError:o});}));}r==="okx"&&((M=(v=Ot()).subscription)==null||M.call(v,()=>{oe({onError:o});}));},[r,c,l]),null},Yn=()=>(Hi(),null);var Vi=new QueryClient({}),Al=r=>{var s=r,{children:e,grazOptions:n}=s,o=tn(s,["children","grazOptions"]);return useEffect(()=>{kn(n);},[n]),jsx(QueryClientProvider,J(F({client:Vi},o),{children:jsxs(Vn,{children:[e,jsx(Yn,{})]})}),"graz-provider")};/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)
*/

export { Yn as GrazEvents, Al as GrazProvider, on as WALLET_TYPES, nn as WalletType, te as checkWallet, zt as clearRecentChain, Z as clearSession, kn as configureGraz, ye as connect, ia as defineChainInfo, na as defineChains, Ce as disconnect, _n as executeContract, Ms as getAvailableWallets, Hs as getChainInfo, Qs as getChainInfos, Et as getCosmostation, ie as getEthereumHexAddress, xt as getKeplr, Tt as getLeap, Sn as getMetamaskSnapLeap, Tn as getOfflineSigners, Dn as getQueryRaw, Rn as getQuerySmart, qs as getRecentChainIds, zs as getRecentChains, Mt as getVectis, In as getWCCosmostation, bn as getWCKeplr, En as getWCLeap, Q as getWallet, ue as getWalletConnect, ks as getWalletType, Wn as instantiateContract, qt as isCapsule, xn as isWalletConnect, oe as reconnect, Pn as sendIbcTokens, Mn as sendTokens, Ht as suggestChain, vn as suggestChainAndConnect, he as useAccount, uc as useActiveChainCurrency, ac as useActiveChainIds, Fi as useActiveChains, Ma as useActiveWalletType, qa as useBalance, ja as useBalanceStaked, Ni as useBalances, ec as useCapsule, cc as useChainInfo, lc as useChainInfos, Rt as useCheckWallet, za as useConnect, Xt as useCosmWasmClient, Gc as useCosmWasmSigningClient, zc as useCosmWasmTmSigningClient, Ha as useDisconnect, xc as useExecuteContract, Hi as useGrazEvents, Oc as useInstantiateContract, Qa as useOfflineSigners, pc as useQueryClientValidators, vc as useQueryRaw, Tc as useQuerySmart, dc as useRecentChainIds, fc as useRecentChains, Ec as useSendIbcTokens, bc as useSendTokens, Yt as useStargateClient, Uc as useStargateSigningClient, qc as useStargateTmSigningClient, mc as useSuggestChain, gc as useSuggestChainAndConnect, _t as useTendermintClient };
