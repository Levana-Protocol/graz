import { create } from 'zustand';
import { createJSONStorage, subscribeWithSelector, persist } from 'zustand/middleware';
import { fromBech32, toBech32 } from '@cosmjs/encoding';
import { Cosmiframe, isInIframe } from '@dao-dao/cosmiframe';
import { isSnapInstalled, installSnap, CosmosSnap } from '@cosmsnap/snapper';
import { rawEd25519PubkeyToRawAddress, rawSecp256k1PubkeyToRawAddress, encodeEd25519Pubkey, encodeSecp256k1Pubkey, pubkeyType } from '@cosmjs/amino';
import on from 'long';
import { SignClient } from '@walletconnect/sign-client';
import { getSdkError } from '@walletconnect/utils';
import { QueryClient, useQuery, useMutation, QueryClientProvider } from '@tanstack/react-query';
import { useMemo, useEffect, useState } from 'react';
import { CosmWasmClient, SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate';
import { StargateClient, SigningStargateClient, GasPrice } from '@cosmjs/stargate';
import { Tendermint37Client, Tendermint34Client } from '@cosmjs/tendermint-rpc';
import { shallow } from 'zustand/shallow';
import { jsxs, jsx, Fragment } from 'react/jsx-runtime';

var Ft=Object.defineProperty,qt=Object.defineProperties;var Gt=Object.getOwnPropertyDescriptors;var ae=Object.getOwnPropertySymbols;var ze=Object.prototype.hasOwnProperty,Qe=Object.prototype.propertyIsEnumerable;var Ge=(e,t,n)=>t in e?Ft(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,x=(e,t)=>{for(var n in t||(t={}))ze.call(t,n)&&Ge(e,n,t[n]);if(ae)for(var n of ae(t))Qe.call(t,n)&&Ge(e,n,t[n]);return e},q=(e,t)=>qt(e,Gt(t));var je=(e,t)=>{var n={};for(var o in e)ze.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(e!=null&&ae)for(var o of ae(e))t.indexOf(o)<0&&Qe.call(e,o)&&(n[o]=e[o]);return n};var c=(e,t,n)=>new Promise((o,r)=>{var i=l=>{try{a(n.next(l));}catch(m){r(m);}},s=l=>{try{a(n.throw(l));}catch(m){r(m);}},a=l=>l.done?o(l.value):Promise.resolve(l.value).then(i,s);a((n=n.apply(e,t)).next());});var H="graz-reconnect-session";var $e=(b=>(b.KEPLR="keplr",b.LEAP="leap",b.VECTIS="vectis",b.COSMOSTATION="cosmostation",b.WALLETCONNECT="walletconnect",b.WC_KEPLR_MOBILE="wc_keplr_mobile",b.WC_LEAP_MOBILE="wc_leap_mobile",b.WC_COSMOSTATION_MOBILE="wc_cosmostation_mobile",b.WC_CLOT_MOBILE="wc_clot_mobile",b.METAMASK_SNAP_LEAP="metamask_snap_leap",b.METAMASK_SNAP_COSMOS="metamask_snap_cosmos",b.STATION="station",b.XDEFI="xdefi",b.CAPSULE="capsule",b.COSMIFRAME="cosmiframe",b.COMPASS="compass",b.INITIA="initia",b))($e||{}),Ve=["keplr","leap","vectis","cosmostation","walletconnect","wc_keplr_mobile","wc_leap_mobile","wc_cosmostation_mobile","wc_clot_mobile","metamask_snap_leap","station","xdefi","capsule","metamask_snap_cosmos","cosmiframe","compass","initia"];var Qt={iframeOptions:null,recentChainIds:null,chains:null,chainsConfig:null,capsuleConfig:null,capsuleState:null,multiChainFetchConcurrency:3,walletType:"keplr",walletConnect:{options:null,web3Modal:null},walletDefaultOptions:null,_notFoundFn:()=>null,_onReconnectFailed:()=>null,_reconnect:!1,_reconnectConnector:null},ne={accounts:null,activeChainIds:null,status:"disconnected",wcSignClients:new Map,capsuleClient:null},jt={name:"graz-session",version:2,partialize:e=>({accounts:e.accounts,activeChainIds:e.activeChainIds}),storage:createJSONStorage(()=>sessionStorage)},$t={name:"graz-internal",partialize:e=>({recentChainIds:e.recentChainIds,_reconnect:e._reconnect,_reconnectConnector:e._reconnectConnector,walletType:e.walletType}),version:2},g=create(subscribeWithSelector(persist(()=>ne,jt))),u=create(subscribeWithSelector(persist(()=>Qt,$t)));var ce=()=>{var d,S;if(!((d=u.getState().capsuleConfig)!=null&&d.apiKey)||!((S=u.getState().capsuleConfig)!=null&&S.env))throw new Error("Capsule configuration is not set");let e=()=>c(void 0,null,function*(){var h,O;let p=(yield import('@leapwallet/cosmos-social-login-capsule-provider')).CapsuleProvider,f=new p({apiKey:(h=u.getState().capsuleConfig)==null?void 0:h.apiKey,env:(O=u.getState().capsuleConfig)==null?void 0:O.env});return g.setState({capsuleClient:f}),f});return {init:e,enable:p=>c(void 0,null,function*(){let f=typeof p=="string"?[p]:p,h=g.getState().capsuleClient;h||(h=yield e()),u.setState({capsuleState:{showModal:!0,chainId:f}});}),onAfterLoginSuccessful:()=>c(void 0,null,function*(){var b;let p=g.getState().capsuleClient,{chains:f}=u.getState();if(!p)throw new Error("Capsule client is not initialized");if(!f)throw new Error("Chains are not set");yield p.enable();let h=(b=u.getState().capsuleState)==null?void 0:b.chainId;if(!h)throw new Error("Chain ids are not set");let O=Object.fromEntries(yield Promise.all(h.map(y=>c(void 0,null,function*(){let I=yield p.getAccount(y);return [y,{address:fromBech32(I.address).data,bech32Address:I.address,algo:I.algo,name:I.username||"",pubKey:I.pubkey,isKeystone:!1,isNanoLedger:!1}]}))));g.setState(y=>({accounts:x(x({},y.accounts||{}),O)})),u.setState(y=>({recentChainIds:[...y.recentChainIds||[],...h].filter((I,v,R)=>R.indexOf(I)===v)})),g.setState(y=>({activeChainIds:[...y.activeChainIds||[],...h].filter((I,v,R)=>R.indexOf(I)===v)})),u.setState({walletType:"capsule",_reconnect:!1,_reconnectConnector:"capsule"}),g.setState({status:"connected"}),typeof window!="undefined"&&window.sessionStorage.setItem(H,"Active"),u.setState({capsuleState:null});}),getKey:p=>c(void 0,null,function*(){let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");let h=yield f.getAccount(p);return {address:fromBech32(h.address).data,bech32Address:h.address,algo:h.algo,name:h.username||"",pubKey:h.pubkey,isKeystone:!1,isNanoLedger:!1}}),getOfflineSignerAuto:p=>c(void 0,null,function*(){let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");return f.getOfflineSignerDirect(p)}),getOfflineSignerDirect:p=>{let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");return f.getOfflineSignerDirect(p)},signDirect:(...p)=>c(void 0,null,function*(){let[f,h,O]=p,b=g.getState().capsuleClient;if(!b)throw new Error("Capsule client is not initialized");return b.signDirect(f,h,{bodyBytes:O.bodyBytes,authInfoBytes:O.authInfoBytes,chainId:O.chainId,accountNumber:O.accountNumber})}),signAmino:(...p)=>c(void 0,null,function*(){let[f,h,O,b]=p,y=g.getState().capsuleClient;if(!y)throw new Error("Capsule client is not initialized");return y.signAmino(f,h,O,b)}),experimentalSuggestChain:(...p)=>c(void 0,null,function*(){yield Promise.reject(new Error("Capsule does not support experimentalSuggestChain"));}),getOfflineSigner:p=>{let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");return f.getOfflineSigner(p)},getOfflineSignerAmino:p=>{let f=g.getState().capsuleClient;if(!f)throw new Error("Capsule client is not initialized");return f.getOfflineSignerAmino(p)}}};var le=()=>{if(typeof window.compass!="undefined"){let e=window.compass;return Object.assign(e,{subscription:r=>{let i=()=>{N(),r();};return window.addEventListener("leap_keystorechange",i),()=>{window.removeEventListener("leap_keystorechange",i);}},setDefaultOptions:r=>{e.defaultOptions=r;}})}throw u.getState()._notFoundFn(),new Error("window.leap is not defined")};var ue=()=>{let e=u.getState();if(!e.iframeOptions)throw e._notFoundFn(),new Error("no iframe options set");if(!isInIframe())throw e._notFoundFn(),new Error("not in iframe");if(!e.iframeOptions.allowedIframeParentOrigins.length)throw e._notFoundFn(),new Error("no iframe allowed origins");let t=new Cosmiframe(e.iframeOptions.allowedIframeParentOrigins).getKeplrClient();return {enable:t.enable.bind(t),getKey:t.getKey.bind(t),getOfflineSigner:t.getOfflineSigner.bind(t),getOfflineSignerAuto:t.getOfflineSignerAuto.bind(t),getOfflineSignerOnlyAmino:t.getOfflineSignerOnlyAmino.bind(t),experimentalSuggestChain:t.experimentalSuggestChain.bind(t),signDirect:t.signDirect.bind(t),signAmino:t.signAmino.bind(t)}};var tt={},nt=()=>{let e=window.ethereum,t=window.cosmos;if(e)return {init:()=>c(void 0,null,function*(){var w;let i=yield e.request({method:"web3_clientVersion"});if(!i.includes("MetaMask"))throw new Error("Metamask is not installed");if(typeof window.okxwallet!="undefined"&&window.okxwallet.isOkxWallet)throw new Error("You have OKX Wallet installed. Please disable and reload the page to use Metamask Snap.");let a=(w=i.split("MetaMask/v")[1])==null?void 0:w.split(".")[0];if(!(Number(a)>=11))throw new Error("Metamask Snap is not supported in this version");return (yield isSnapInstalled())||(yield installSnap()),window.cosmos=new CosmosSnap,t=window.cosmos,!0}),enable:i=>c(void 0,null,function*(){(yield isSnapInstalled())||(yield installSnap());}),getOfflineSigner:i=>t.getOfflineSigner(i),experimentalSuggestChain:i=>c(void 0,null,function*(){yield t.experimentalSuggestChain(i);}),signAmino:(i,s,a)=>c(void 0,null,function*(){return t.signAmino(i,s,a)}),getKey:i=>c(void 0,null,function*(){return typeof tt[i]!="undefined"?tt[i]:t.getKey(i)}),getOfflineSignerAuto:i=>c(void 0,null,function*(){return (yield t.getKey(i)).isNanoLedger?t.getOfflineSignerOnlyAmino(i):t.getOfflineSigner(i)}),getOfflineSignerOnlyAmino:i=>t.getOfflineSignerOnlyAmino(i),signDirect:(i,s,a)=>c(void 0,null,function*(){return t.signDirect(i,s,a)}),signArbitrary:(i,s,a)=>c(void 0,null,function*(){return t.signArbitrary(i,s,a)}),disable:i=>c(void 0,null,function*(){i&&(yield t.deleteChain(i));})};throw u.getState()._notFoundFn(),new Error("window.ethereum is not defined")};var pe=()=>{var e;if(typeof((e=window.cosmostation)==null?void 0:e.providers.keplr)!="undefined"){let t=window.cosmostation.providers.keplr;return Object.assign(t,{subscription:i=>{let s=()=>{N(),i();};return window.addEventListener("cosmostation_keystorechange",s),()=>{window.removeEventListener("cosmostation_keystorechange",s);}},setDefaultOptions:i=>{t.defaultOptions=i;}})}throw u.getState()._notFoundFn(),new Error("window.cosmostation.providers.keplr is not defined")};var tn=e=>{let{bodyBytes:t,authInfoBytes:n,chainId:o,accountNumber:r}=e;if(!t||!n||!o||!r)throw new Error("Invalid sign doc");return {bodyBytes:t,authInfoBytes:n,chainId:o,accountNumber:r}},nn=e=>`${e.slice(0,6)}...${e.slice(-6)}`,ot=()=>{if(typeof window.initia!="undefined"){let e=window.initia;return {enable:()=>c(void 0,null,function*(){yield e.getAddress();}),getKey:d=>c(void 0,null,function*(){let S=e.getOfflineSigner(d),[p]=yield S.getAccounts();if(!p)throw new Error("Wallet connection failed");let f=(()=>{switch(p.algo){case"secp256k1":return rawSecp256k1PubkeyToRawAddress(p.pubkey);case"ed25519":return rawEd25519PubkeyToRawAddress(p.pubkey);default:throw new Error("sr25519 public key algorithm is not supported")}})();return {name:nn(p.address),algo:p.algo,pubKey:p.pubkey,bech32Address:p.address,address:f,isNanoLedger:!1,isKeystone:!1}}),getOfflineSigner:d=>{let S=e.getOfflineSigner(d),p=e.getOfflineSignerOnlyAmino(d);return {getAccounts:S.getAccounts.bind(S),signDirect:S.signDirect.bind(S),signAmino:p.signAmino.bind(p)}},getOfflineSignerAuto:d=>Promise.resolve(e.getOfflineSigner(d)),getOfflineSignerOnlyAmino:d=>e.getOfflineSignerOnlyAmino(d),experimentalSuggestChain:d=>e.requestAddInitiaLayer({chain_id:d.chainId,chain_name:d.chainName,bech32_prefix:"init",bech32_config:d.bech32Config,slip44:d.bip44.coinType,logo_URIs:{png:d.chainSymbolImageUrl},fees:{fee_tokens:d.feeCurrencies.map(S=>{var p,f,h;return {denom:S.coinDenom,amount:S.coinMinimalDenom,low_gas_price:(p=S.gasPriceStep)==null?void 0:p.low,average_gas_price:(f=S.gasPriceStep)==null?void 0:f.average,high_gas_price:(h=S.gasPriceStep)==null?void 0:h.high}})},apis:{rpc:[{address:d.rpc}],rest:[{address:d.rest}]}}),signDirect:(...d)=>{let[S,p,f]=d;return e.getOfflineSigner(S).signDirect(p,tn(f))},signAmino:(...d)=>{let[S,p,f]=d;return e.getOfflineSignerOnlyAmino(S).signAmino(p,f)},signArbitrary:(d,S,p)=>c(void 0,null,function*(){let O=(yield e.getOfflineSigner(d).getAccounts()).find(I=>I.address===S);if(!O)throw new Error(`Wallet not connected to account ${S}`);let b=(()=>{switch(O.algo){case"secp256k1":return encodeSecp256k1Pubkey(O.pubkey);case"ed25519":return encodeEd25519Pubkey(O.pubkey);default:throw new Error("sr25519 public key algorithm is not supported")}})();return {signature:yield e.signArbitrary(p),pub_key:{type:O.algo==="secp256k1"?pubkeyType.secp256k1:pubkeyType.ed25519,value:b.value}}}),subscription:d=>{let S=()=>{N(),d();};return window.addEventListener("initia_keystorechange",S),()=>{window.removeEventListener("initia_keystorechange",S);}}}}throw u.getState()._notFoundFn(),new Error("window.initia is not defined")};var me=()=>{if(typeof window.keplr!="undefined"){let e=window.keplr;return Object.assign(e,{subscription:r=>{let i=()=>{N(),r();};return window.addEventListener("keplr_keystorechange",i),()=>{window.removeEventListener("keplr_keystorechange",i);}},setDefaultOptions:r=>{e.defaultOptions=r;}})}throw u.getState()._notFoundFn(),new Error("window.keplr is not defined")};var de=()=>{if(typeof window.leap!="undefined"){let e=window.leap;return Object.assign(e,{subscription:r=>{let i=()=>{N(),r();};return window.addEventListener("leap_keystorechange",i),()=>{window.removeEventListener("leap_keystorechange",i);}},setDefaultOptions:r=>{e.defaultOptions=r;}})}throw u.getState()._notFoundFn(),new Error("window.leap is not defined")};var fe={},rt=e=>{let t=window.ethereum;if(t&&e){let n=()=>c(void 0,null,function*(){return yield t.request({method:"wallet_getSnaps"})}),o=y=>c(void 0,null,function*(){try{let I=yield n();return Object.values(I).find(v=>v.id===e.id&&(!y||v.version===y))}catch(I){return}}),r=()=>c(void 0,null,function*(){yield t.request({method:"wallet_requestSnaps",params:{[e.id]:e.params||{}}});}),i=()=>c(void 0,null,function*(){var _;let y=yield t.request({method:"web3_clientVersion"});if(!y.includes("MetaMask"))throw new Error("Metamask is not installed");if(typeof window.okxwallet!="undefined"&&window.okxwallet.isOkxWallet)throw new Error("You have OKX Wallet installed. Please disable and reload the page to use Metamask Snap.");let v=(_=y.split("MetaMask/v")[1])==null?void 0:_.split(".")[0];if(!(Number(v)>=11))throw new Error("Metamask Snap is not supported in this version");return (yield o())||(yield r()),!0}),s=y=>c(void 0,null,function*(){(yield o())||(yield r());}),a=(y,I,v)=>c(void 0,null,function*(){let R=yield t.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"signDirect",params:{chainId:y,signerAddress:I,signDoc:v}}}}),K=v.accountNumber,_=new on(K.low,K.high,K.unsigned);return {signature:R.signature,signed:q(x({},R.signed),{accountNumber:_.toString(),authInfoBytes:new Uint8Array(Object.values(R.signed.authInfoBytes)),bodyBytes:new Uint8Array(Object.values(R.signed.bodyBytes))})}}),l=(y,I,v)=>c(void 0,null,function*(){return yield t.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"signAmino",params:{chainId:y,signerAddress:I,signDoc:v}}}})}),m=y=>c(void 0,null,function*(){if(typeof fe[y]!="undefined")return fe[y];let I=yield t.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"getKey",params:{chainId:y}}}});if(!I)throw new Error("No response from Metamask");return I.pubKey=Uint8Array.from(Object.values(I.pubkey)),delete I.pubkey,fe[y]=I,fe[y]}),w=y=>c(void 0,null,function*(){let I=yield m(y);return {address:I.bech32Address,algo:I.algo,pubkey:I.pubKey}}),d=(...y)=>c(void 0,null,function*(){let[I,v,R,K]=y;return yield l(I,v,R)}),S=(...y)=>c(void 0,null,function*(){let[I,v,R]=y;return yield a(I,v,R)}),f=y=>({getAccounts:()=>c(void 0,null,function*(){return [yield w(y)]}),signAmino:(I,v)=>d(y,I,v)});return {enable:s,experimentalSuggestChain:(...y)=>c(void 0,null,function*(){yield i(),yield t.request({method:"wallet_invokeSnap",params:{snapId:e.id,request:{method:"suggestChain",params:{chainInfo:y[0]}}}});}),getKey:m,getOfflineSigner:y=>({getAccounts:()=>c(void 0,null,function*(){return [yield w(y)]}),signDirect:(I,v)=>S(y,I,v),signAmino:(I,v)=>d(y,I,v)}),getOfflineSignerAuto:y=>c(void 0,null,function*(){return f(y)}),getOfflineSignerOnlyAmino:f,init:i,signAmino:d,signDirect:S}}throw u.getState()._notFoundFn(),new Error("window.ethereum is not defined")};var st=()=>rt({id:"npm:@leapwallet/metamask-cosmos-snap"});var ge=()=>{if(typeof window.station!="undefined"){let e=window.station.keplr;return {subscription:i=>{let s=()=>{N(),i();};return window.addEventListener("station_wallet_change",s),()=>{window.removeEventListener("station_wallet_change",s);}},getKey:i=>c(void 0,null,function*(){let s=yield e.getKey(i);return x({isKeystone:!1},s)}),getOfflineSigner:i=>{try{let s=e.getOfflineSignerOnlyAmino(i);return Object.assign(s,{signDirect:(m,w)=>{throw new Error("signDirect not supported by Station")}})}catch(s){throw console.error(s),s}},experimentalSuggestChain:i=>c(void 0,null,function*(){try{let s=Object.assign(i,{chainSymbolImageUrl:i.chainSymbolImageUrl||"",stakeCurrency:{coinDecimals:i.stakeCurrency.coinDecimals,coinDenom:i.stakeCurrency.coinDenom,coinImageUrl:i.stakeCurrency.coinImageUrl||"",coinMinimalDenom:i.stakeCurrency.coinMinimalDenom},currencies:i.currencies.map(a=>({coinDecimals:a.coinDecimals,coinDenom:a.coinDenom,coinImageUrl:a.coinImageUrl||"",coinMinimalDenom:a.coinMinimalDenom})),feeCurrencies:i.feeCurrencies.map(a=>{var l,m,w;return {coinDecimals:a.coinDecimals,coinDenom:a.coinDenom,coinImageUrl:a.coinImageUrl||"",coinMinimalDenom:a.coinMinimalDenom,gasPriceStep:{average:((l=a.gasPriceStep)==null?void 0:l.average)||0,high:((m=a.gasPriceStep)==null?void 0:m.high)||0,low:((w=a.gasPriceStep)==null?void 0:w.low)||0}}})});yield e.experimentalSuggestChain(s);}catch(s){throw console.error(s),s}}),enable:i=>e.enable(i),disable:i=>e.disable(i),getOfflineSignerAuto:i=>e.getOfflineSignerAuto(i),getOfflineSignerOnlyAmino:i=>e.getOfflineSignerOnlyAmino(i),signDirect:()=>e.signDirect(),signAmino:(i,s,a,l)=>e.signAmino(i,s,a)}}throw u.getState()._notFoundFn(),new Error("window.station is not defined")};var ye=()=>{if(typeof window.vectis!="undefined"){let e=window.vectis.cosmos;return {enable:a=>e.enable(a),getOfflineSigner:a=>e.getOfflineSigner(a),getOfflineSignerAuto:a=>e.getOfflineSignerAuto(a),getKey:a=>c(void 0,null,function*(){let l=yield e.getKey(a);return {address:fromBech32(l.address).data,algo:l.algo,bech32Address:l.address,name:l.name,pubKey:l.pubKey,isKeystone:!1,isNanoLedger:l.isNanoLedger}}),subscription:a=>{let l=()=>{N(),a();};return window.addEventListener("vectis_accountChanged",l),()=>{window.removeEventListener("vectis_accountChanged",l);}},getOfflineSignerOnlyAmino:(...a)=>e.getOfflineSignerAmino(...a),experimentalSuggestChain:(...a)=>c(void 0,null,function*(){let[l]=a,m=q(x({},l),{rpcUrl:l.rpc,restUrl:l.rest,prettyName:l.chainName.replace(" ",""),bech32Prefix:l.bech32Config.bech32PrefixAccAddr});return e.suggestChains([m])}),signDirect:(...a)=>c(void 0,null,function*(){var w;let{1:l,2:m}=a;return e.signDirect(l,{bodyBytes:m.bodyBytes||Uint8Array.from([]),authInfoBytes:m.authInfoBytes||Uint8Array.from([]),accountNumber:on.fromString(((w=m.accountNumber)==null?void 0:w.toString())||"",!1),chainId:m.chainId||""})}),signAmino:(...a)=>c(void 0,null,function*(){let{1:l,2:m}=a;return e.signAmino(l,m)})}}throw u.getState()._notFoundFn(),new Error("window.vectis is not defined")};var Q=()=>typeof window!="undefined"?!!(window.matchMedia("(pointer:coarse)").matches||/Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)):!1,at=()=>Q()&&navigator.userAgent.toLowerCase().includes("android"),ct=()=>Q()&&(navigator.userAgent.toLowerCase().includes("iphone")||navigator.userAgent.toLowerCase().includes("ipad"));var xe=(e,t,n=new Error("Promise timed out"))=>{let o=new Promise((r,i)=>{setTimeout(()=>{i(n);},t);});return Promise.race([e,o])};var j=e=>{var _,J,ie;if(!((ie=(J=(_=u.getState().walletConnect)==null?void 0:_.options)==null?void 0:J.projectId)!=null&&ie.trim()))throw new Error("walletConnect.options.projectId is not defined");let t=(e==null?void 0:e.walletType)||"walletconnect",n=(e==null?void 0:e.encoding)||"base64",o=C=>{if(!e)return;let{appUrl:A,formatNativeUrl:E}=e;if(Q()){if(at())if(!C)window.open(A.mobile.android,"_self","noreferrer noopener");else {let k=E(A.mobile.android,C,"android");window.open(k,"_self","noreferrer noopener");}if(ct())if(!C)window.open(A.mobile.ios,"_self","noreferrer noopener");else {let k=E(A.mobile.ios,C,"ios");window.open(k,"_self","noreferrer noopener");}}},r=()=>{let{wcSignClients:C}=g.getState();if(!C.get(t))throw new Error("walletConnect.signClient is not defined");C.delete(t),g.setState({wcSignClients:C}),u.setState({_reconnect:!1,_reconnectConnector:null,recentChainIds:null});},i=C=>c(void 0,null,function*(){let{wcSignClients:A}=g.getState(),E=A.get(t);if(!E)throw new Error("walletConnect.signClient is not defined");if(!C)throw new Error("No wallet connect session");yield E.disconnect({topic:C,reason:getSdkError("USER_DISCONNECTED")}),yield l(E);}),s=C=>{try{let{wcSignClients:A}=g.getState(),E=A.get(t);if(!E)throw new Error("walletConnect.signClient is not defined");let k=E.session.getAll().at(-1);if(!k)return;if(!(k.expiry*1e3>Date.now()+1e3))throw i(k.topic),new Error("invalid session");try{let P=E.find({requiredNamespaces:{cosmos:{methods:["cosmos_getAccounts","cosmos_signAmino","cosmos_signDirect"],chains:C.map(U=>`cosmos:${U}`),events:["chainChanged","accountsChanged"]}}});if(!P.length)throw new Error("no session");return P.at(-1)}catch(P){if(!P.message.toLowerCase().includes("no matching key"))throw P}return k}catch(A){if(!A.message.toLowerCase().includes("no matching key"))throw A}},a=C=>{try{return s(C)}catch(A){return}},l=C=>c(void 0,null,function*(){try{let A=C.core.pairing.pairings.getAll({active:!1});if(!A.length)return;yield Promise.all(A.map(E=>c(void 0,null,function*(){yield C.core.pairing.pairings.delete(E.topic,{code:7001,message:"clear pairing"});})));}catch(A){if(!A.message.toLowerCase().includes("no matching key"))throw A}}),m=()=>c(void 0,null,function*(){let{walletConnect:C}=u.getState();if(!(C!=null&&C.options))throw new Error("walletConnect.options is not defined");let{wcSignClients:A}=g.getState(),E=A.get(t);if(E)return E;let k=yield SignClient.init(C.options);return A.set(t,k),g.setState({wcSignClients:A}),k}),w=C=>{let{wcSignClients:A}=g.getState(),E=A.get(t);if(!E)return ()=>{};let k=W=>{let P=g.getState().accounts;if(W.params.event.name==="accountsChanged"&&P&&!Object.values(P).map(U=>U.bech32Address).includes(W.params.event.data[0])){let U=W.params.chainId.split(":")[1];U&&d([U]);}else C();};return E.events.on("session_delete",r),E.events.on("session_expire",r),E.events.on("session_event",k),()=>{E.events.off("session_delete",r),E.events.off("session_expire",r),E.events.off("session_event",k);}},d=C=>c(void 0,null,function*(){var re;let A=typeof C=="string"?[C]:C,{wcSignClients:E}=g.getState(),k=E.get(t);if(!k)throw new Error("enable walletConnect.signClient is not defined");let{walletConnect:W,chains:P}=u.getState();if(!((re=W==null?void 0:W.options)!=null&&re.projectId))throw new Error("walletConnect.options.projectId is not defined");let{Web3Modal:U}=yield import('@web3modal/standalone'),V=new U(x({projectId:W.options.projectId,walletConnectVersion:2,enableExplorer:!1,explorerRecommendedWalletIds:"NONE"},W.web3Modal)),Z=a(A);if(!Z){let{uri:F,approval:ee}=yield xe(k.connect({requiredNamespaces:{cosmos:{methods:["cosmos_getAccounts","cosmos_signAmino","cosmos_signDirect"],chains:A.map($=>`cosmos:${$}`),events:["chainChanged","accountsChanged"]}}}),15e3,new Error("Connection timeout"));if(!F)throw new Error("No wallet connect uri");e?o(F):yield V.openModal({uri:F});let Lt=$=>c(void 0,null,function*(){return $.aborted?Promise.reject(new Error("User closed wallet connect")):new Promise((Te,te)=>{ee().then(Le=>{let Ue=Le.sessionProperties;if(!Ue)return te(new Error("No session properties"));let Me=JSON.parse(String(Ue.keys));if(Me.length===0)return te(new Error("No accounts"));let Fe=Me[0];if(!Fe)return te(new Error("No accounts"));let qe={};return A.forEach(se=>{qe[se]=q(x({},Fe),{bech32Address:toBech32(P.find(Ut=>Ut.chainId===se).bech32Config.bech32PrefixAccAddr,fromBech32(Me[0].bech32Address).data)});}),g.setState(se=>({accounts:x(x({},se.accounts||{}),qe)})),Te(Le)}).catch(te),$.addEventListener("abort",()=>{te(new Error("User closed wallet connect"));},{once:!0});})});try{let $=new AbortController,Te=$.signal;V.subscribeModal(te=>{te.open||$.abort();}),yield Lt(Te);}catch($){if(V.closeModal(),$ instanceof Error&&!$.message.toLowerCase().includes("no matching key"))return Promise.reject($)}return e||V.closeModal(),Promise.resolve()}try{yield xe((()=>c(void 0,null,function*(){let F=Object.fromEntries(yield Promise.all(A.map(ee=>c(void 0,null,function*(){return [ee,yield p(ee)]}))));g.setState({accounts:F});}))(),15e3,new Error("Connection timeout"));}catch(F){if(i(Z.topic),!F.message.toLowerCase().includes("no matching key"))throw F}}),S=C=>c(void 0,null,function*(){var P;let{wcSignClients:A}=g.getState(),E=A.get(t);if(!E)throw new Error("walletConnect.signClient is not defined");let k=(P=s([C]))==null?void 0:P.topic;if(!k)throw new Error("No wallet connect session");let W=yield E.request({topic:k,chainId:`cosmos:${C}`,request:{method:"cosmos_getAccounts",params:{}}});if(!W[0])throw new Error("No wallet connect account");return {address:W[0].address,algo:W[0].algo,pubkey:new Uint8Array(Buffer.from(W[0].pubkey,n))}}),p=C=>c(void 0,null,function*(){let A=s([C]);if(!(A!=null&&A.topic))throw new Error("No wallet connect session");let E=A.sessionProperties&&JSON.parse(String(A.sessionProperties.keys))[0];if(!E)throw new Error("No wallet connect key");return E}),f=(...C)=>c(void 0,null,function*(){var F,ee;let[A,E,k]=C,{accounts:W,wcSignClients:P}=g.getState(),U=P.get(t);if(!U)throw new Error("walletConnect.signClient is not defined");if(!W)throw new Error("account is not defined");let V=(F=s([A]))==null?void 0:F.topic;if(!V)throw new Error("No wallet connect session");if(!k.bodyBytes)throw new Error("No bodyBytes");if(!k.authInfoBytes)throw new Error("No authInfoBytes");let Z={topic:V,chainId:`cosmos:${A}`,request:{method:"cosmos_signDirect",params:{signerAddress:E,signDoc:q(x({},k),{bodyBytes:Buffer.from(k.bodyBytes).toString(n),authInfoBytes:Buffer.from(k.authInfoBytes).toString(n),accountNumber:(ee=k.accountNumber)==null?void 0:ee.toString()})}}};return o(),yield U.request(Z)}),h=(...C)=>c(void 0,null,function*(){let[A,E,k]=C,{signature:W,signed:P}=yield f(A,E,k);return {signed:{chainId:P.chainId,accountNumber:on.fromString(P.accountNumber,!1),authInfoBytes:new Uint8Array(Buffer.from(P.authInfoBytes,n)),bodyBytes:new Uint8Array(Buffer.from(P.bodyBytes,n))},signature:W}}),O=(...C)=>c(void 0,null,function*(){var F;let[A,E,k,W]=C,{wcSignClients:P}=g.getState(),U=P.get(t),{accounts:V}=g.getState();if(!U)throw new Error("walletConnect.signClient is not defined");if(!V)throw new Error("account is not defined");let Z=(F=s([A]))==null?void 0:F.topic;if(!Z)throw new Error("No wallet connect session");return o(),yield U.request({topic:Z,chainId:`cosmos:${A}`,request:{method:"cosmos_signDirect",params:{signerAddress:E,signDoc:k}}})}),b=(...C)=>c(void 0,null,function*(){let[A,E,k,W]=C;return yield O(A,E,k)}),y=C=>({getAccounts:()=>c(void 0,null,function*(){return [yield S(C)]}),signDirect:(A,E)=>h(C,A,E)}),I=C=>({getAccounts:()=>c(void 0,null,function*(){return [yield S(C)]}),signAmino:(A,E)=>b(C,A,E)});return {enable:d,disable:C=>c(void 0,null,function*(){var k;let{wcSignClients:A}=g.getState(),E=A.get(t);if(C===void 0){let W=E==null?void 0:E.session.getAll();W!==void 0&&(yield Promise.all(W.map(P=>i(P.topic))));}else typeof C=="string"?yield i((k=s([C]))==null?void 0:k.topic):yield Promise.all(C.map(W=>{var P;return i((P=s([W]))==null?void 0:P.topic)}));(E==null?void 0:E.session.getAll().length)===0&&r();}),experimentalSuggestChain:(...C)=>c(void 0,null,function*(){yield Promise.reject(new Error("WalletConnect does not support experimentalSuggestChain"));}),getKey:p,getOfflineSigner:C=>({getAccounts:()=>c(void 0,null,function*(){return [yield S(C)]}),signDirect:(A,E)=>h(C,A,E),signAmino:(A,E)=>b(C,A,E)}),getOfflineSignerAuto:C=>c(void 0,null,function*(){return (yield p(C)).isNanoLedger?I(C):y(C)}),getOfflineSignerOnlyAmino:I,signAmino:b,signDirect:h,subscription:w,init:m}};var lt=()=>{var t,n,o;if(!((o=(n=(t=u.getState().walletConnect)==null?void 0:t.options)==null?void 0:n.projectId)!=null&&o.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!Q())throw new Error("WalletConnect Clot mobile is only supported in mobile");let e={encoding:"base64",appUrl:{mobile:{android:"clot://",ios:"clot://"}},walletType:"wc_clot_mobile",formatNativeUrl:(r,i,s)=>{let a=r.replaceAll("/","").replaceAll(":",""),l=encodeURIComponent(i);switch(s){case"ios":return `${a}://wcV2?${l}`;default:return `${a}://wc?uri=${l}`}}};return j(e)};var ut=()=>{var t,n,o;if(!((o=(n=(t=u.getState().walletConnect)==null?void 0:t.options)==null?void 0:n.projectId)!=null&&o.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!Q())throw new Error("WalletConnect Cosmostation mobile is only supported in mobile");let e={encoding:"hex",appUrl:{mobile:{ios:"cosmostation://",android:"cosmostation://"}},walletType:"wc_cosmostation_mobile",formatNativeUrl:(r,i,s)=>`${r.replaceAll("/","").replaceAll(":","")}://wc?${i}`};return j(e)};var pt=()=>{var t,n,o;if(!((o=(n=(t=u.getState().walletConnect)==null?void 0:t.options)==null?void 0:n.projectId)!=null&&o.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!Q())throw new Error("WalletConnect Keplr mobile is only supported in mobile");let e={encoding:"base64",appUrl:{mobile:{ios:"keplrwallet://",android:"intent://"}},walletType:"wc_keplr_mobile",formatNativeUrl:(r,i,s)=>{let a=r.replaceAll("/","").replaceAll(":",""),l=encodeURIComponent(i);switch(s){case"ios":return `${a}://wcV2?${l}`;case"android":return `${a}://wcV2?${l}#Intent;package=com.chainapsis.keplr;scheme=keplrwallet;end;`;default:return `${a}://wc?uri=${l}`}}};return j(e)};var mt=()=>{var t,n,o;if(!((o=(n=(t=u.getState().walletConnect)==null?void 0:t.options)==null?void 0:n.projectId)!=null&&o.trim()))throw new Error("walletConnect.options.projectId is not defined");if(!Q())throw new Error("WalletConnect Leap mobile is only supported in mobile");let e={encoding:"base64",appUrl:{mobile:{ios:"leapcosmos://",android:"intent://"}},walletType:"wc_leap_mobile",formatNativeUrl:(r,i,s)=>{let a=r.replaceAll("/","").replaceAll(":",""),l=encodeURIComponent(i);switch(s){case"ios":return `${a}://wcV2?${l}`;case"android":return `${a}://wcV2?${l}#Intent;package=io.leapwallet.cosmos;scheme=leapwallet;end;`;default:return `${a}://wc?uri=${l}`}}};return j(e)};var Se=()=>{var e;if(typeof((e=window.xfi)==null?void 0:e.keplr)!="undefined"){let t=window.xfi.keplr;return Object.assign(t,{subscription:r=>{let i=()=>{N(),r();};return window.addEventListener("keplr_keystorechange",i),()=>{window.removeEventListener("keplr_keystorechange",i);}}})}throw u.getState()._notFoundFn(),new Error("window.xfi.keplr is not defined")};var B=(e=u.getState().walletType)=>{try{return D(e),!0}catch(t){return !1}},N=()=>{window.sessionStorage.removeItem(H),g.setState(ne);},D=(e=u.getState().walletType)=>{var o;let t=(()=>{switch(e){case"keplr":return me();case"leap":return de();case"cosmostation":return pe();case"vectis":return ye();case"walletconnect":return j();case"wc_keplr_mobile":return pt();case"wc_leap_mobile":return mt();case"wc_cosmostation_mobile":return ut();case"wc_clot_mobile":return lt();case"metamask_snap_leap":return st();case"metamask_snap_cosmos":return nt();case"station":return ge();case"xdefi":return Se();case"capsule":return ce();case"cosmiframe":return ue();case"compass":return le();case"initia":return ot();default:throw new Error("Unknown wallet type")}})(),n=u.getState().walletDefaultOptions;return n&&((o=t.setDefaultOptions)==null||o.call(t,n)),t},Ho=()=>Object.fromEntries(Ve.map(e=>[e,B(e)])),ve=e=>e==="capsule",dt=e=>e==="walletconnect"||e==="wc_keplr_mobile"||e==="wc_leap_mobile"||e==="wc_cosmostation_mobile";var Y=e=>c(void 0,null,function*(){var t;try{let{recentChainIds:n,chains:o,walletType:r}=u.getState(),i=(e==null?void 0:e.walletType)||r;if(!B(i))throw new Error(`${i} is not available`);let a=D(i),l=typeof(e==null?void 0:e.chainId)=="string"?[e.chainId]:(e==null?void 0:e.chainId)||n;if(!l)throw new Error("No last known connected chain, connect action requires chain ids");let m=o==null?void 0:o.map(p=>p.chainId);l.forEach(p=>{if(!(m!=null&&m.includes(p)))throw new Error(`Chain ${p} is not provided in GrazProvider`)}),g.setState(p=>{let f=u.getState()._reconnect||!!u.getState()._reconnectConnector||!!l;return p.activeChainIds&&l.filter(O=>{var b;return !((b=p.activeChainIds)!=null&&b.includes(O))}).length>0?{status:"connecting"}:f?{status:"reconnecting"}:{status:"connecting"}});let{accounts:w}=g.getState();if(yield (t=a.init)==null?void 0:t.call(a),ve(i)&&g.getState().capsuleClient&&Object.values(g.getState().accounts||[]).length>0){let p=l.map(O=>o.find(b=>b.chainId===O)),f=g.getState().accounts;g.setState({status:"connecting"});let h=Object.fromEntries(yield Promise.all(l.map(O=>c(void 0,null,function*(){return [O,yield a.getKey(O)]}))));return g.setState(O=>({accounts:x(x({},O.accounts||{}),h)})),u.setState(O=>({recentChainIds:[...O.recentChainIds||[],...l].filter((b,y,I)=>I.indexOf(b)===y)})),g.setState(O=>({activeChainIds:[...O.activeChainIds||[],...l].filter((b,y,I)=>I.indexOf(b)===y)})),g.setState({status:"connected"}),{accounts:f,walletType:i,chains:p}}if(yield a.enable(l),ve(i)){let p=l.map(h=>o.find(O=>O.chainId===h)),f=g.getState().accounts;return g.setState({status:"connecting"}),{accounts:f,walletType:i,chains:p}}if(!dt(i)){let p=Object.fromEntries(yield Promise.all(l.map(f=>c(void 0,null,function*(){return [f,yield a.getKey(f)]}))));g.setState(f=>({accounts:x(x({},f.accounts||{}),p)}));}u.setState(p=>({recentChainIds:[...p.recentChainIds||[],...l].filter((f,h,O)=>O.indexOf(f)===h)})),g.setState(p=>({activeChainIds:[...p.activeChainIds||[],...l].filter((f,h,O)=>O.indexOf(f)===h)})),u.setState({walletType:i,_reconnect:!!(e!=null&&e.autoReconnect),_reconnectConnector:i}),g.setState({status:"connected"}),typeof window!="undefined"&&window.sessionStorage.setItem(H,"Active");let d=l.map(p=>o.find(f=>f.chainId===p));return {accounts:g.getState().accounts,walletType:i,chains:d}}catch(n){throw console.error("connect ",n),g.getState().accounts===null&&g.setState({status:"disconnected"}),g.getState().accounts&&g.getState().activeChainIds&&g.setState({status:"connected"}),n}}),oe=e=>{typeof window!="undefined"&&window.sessionStorage.removeItem(H);let t=typeof(e==null?void 0:e.chainId)=="string"?[e.chainId]:e==null?void 0:e.chainId;if(t){let n=g.getState().accounts;t.forEach(r=>{n==null||delete n[r];}),Object.values(n||{}).length===0?(g.setState(ne),u.setState({_reconnect:!1,_reconnectConnector:null,recentChainIds:null})):(g.setState(r=>{var i;return {activeChainIds:(i=r.activeChainIds)==null?void 0:i.filter(s=>!t.includes(s)),accounts:n}}),u.setState(r=>{var i;return {recentChainIds:(i=r.recentChainIds)==null?void 0:i.filter(s=>!t.includes(s))}}));}else g.setState(ne),u.setState({_reconnect:!1,_reconnectConnector:null,recentChainIds:null});return Promise.resolve()},G=e=>c(void 0,null,function*(){var r;let{recentChainIds:t,_reconnectConnector:n,_reconnect:o}=u.getState();try{let i=B(n||void 0);if(t&&i&&n)return yield Y({chainId:t,walletType:n,autoReconnect:o})}catch(i){(r=e==null?void 0:e.onError)==null||r.call(e,i),oe();}}),ft=e=>c(void 0,null,function*(){if(!(e!=null&&e.chainId))throw new Error("chainId is required");let{walletType:t}=u.getState(),n=e.walletType||t;if(!B(n))throw new Error(`${n} is not available`);let r=D(n),i=r.getOfflineSigner(e.chainId),s=r.getOfflineSignerOnlyAmino(e.chainId),a=yield r.getOfflineSignerAuto(e.chainId);return {offlineSigner:i,offlineSignerAmino:s,offlineSignerAuto:a}});var ke=()=>{u.setState({recentChainIds:null});},ar=()=>u.getState().recentChainIds,cr=()=>{var n;let{recentChainIds:e,chains:t}=u.getState();return (n=e==null?void 0:e.map(o=>t.find(r=>r.chainId===o)))!=null?n:null},lr=({chainId:e})=>{var t;return (t=u.getState().chains)==null?void 0:t.find(n=>n.chainId===e)},ur=({chainId:e})=>{var t;return (t=u.getState().chains)==null?void 0:t.filter(n=>e==null?void 0:e.includes(n.chainId))},Pe=n=>c(void 0,[n],function*({chainInfo:e,walletType:t}){let o=D(t);return t==="capsule"?yield Y({chainId:e.chainId,walletType:t}):yield o.experimentalSuggestChain(e),e}),gt=e=>c(void 0,null,function*(){var o;let t=u.getState().walletType;return yield Pe({chainInfo:e.chainInfo,walletType:(o=e.walletType)!=null?o:t}),yield Y({chainId:e.chainInfo.chainId,walletType:e.walletType,autoReconnect:e.autoReconnect})});var yt=e=>(u.setState(t=>({iframeOptions:e.iframeOptions||t.iframeOptions,walletConnect:e.walletConnect||t.walletConnect,walletType:e.defaultWallet||t.walletType,capsuleConfig:e.capsuleConfig||t.capsuleConfig,walletDefaultOptions:e.walletDefaultOptions||t.walletDefaultOptions,chains:e.chains,chainsConfig:e.chainsConfig||t.chainsConfig,multiChainFetchConcurrency:e.multiChainFetchConcurrency||t.multiChainFetchConcurrency,_notFoundFn:e.onNotFound||t._notFoundFn,_onReconnectFailed:e.onReconnectFailed||t._onReconnectFailed,_reconnect:e.autoReconnect===void 0?!0:e.autoReconnect||t._reconnect})),e);var St=s=>c(void 0,[s],function*({signingClient:e,senderAddress:t,recipientAddress:n,amount:o,fee:r,memo:i}){if(!e)throw new Error("No connected account detected");if(!t)throw new Error("senderAddress is not defined");return e.sendTokens(t,n,o,r,i)}),Ct=w=>c(void 0,[w],function*({signingClient:e,senderAddress:t,recipientAddress:n,transferAmount:o,sourcePort:r,sourceChannel:i,timeoutHeight:s,timeoutTimestamp:a,fee:l,memo:m}){if(!e)throw new Error("Stargate signing client is not ready");if(!t)throw new Error("senderAddress is not defined");return e.sendIbcTokens(t,n,o,r,i,s,a,l,m)}),ht=a=>c(void 0,[a],function*({signingClient:e,senderAddress:t,msg:n,fee:o,options:r,label:i,codeId:s}){if(!e)throw new Error("CosmWasm signing client is not ready");return e.instantiate(t,s,n,i,o,r)}),wt=a=>c(void 0,[a],function*({signingClient:e,senderAddress:t,msg:n,fee:o,contractAddress:r,funds:i,memo:s}){if(!e)throw new Error("CosmWasm signing client is not ready");return e.execute(t,r,n,o,s,i)}),At=(e,t,n)=>c(void 0,null,function*(){if(!n)throw new Error("CosmWasm client is not ready");return yield n.queryContractSmart(e,t)}),It=(e,t,n)=>{if(!n)throw new Error("CosmWasm client is not ready");let o=new TextEncoder().encode(t);return n.queryContractRaw(e,o)};var wr=e=>e,Ar=e=>e;var Ce=e=>e?Object.keys(e).length===0:!0;var We=class extends Error{constructor(t){super(),this.name="AbortError",this.message=t;}},Ot=e=>globalThis.DOMException===void 0?new We(e):new DOMException(e),Et=e=>{let t=e.reason===void 0?Ot("This operation was aborted."):e.reason;return t instanceof Error?t:Ot(t)};function Re(i,s){return c(this,arguments,function*(e,t,{concurrency:n=Number.POSITIVE_INFINITY,stopOnError:o=!0,signal:r}={}){return new Promise((a,l)=>{if(e[Symbol.iterator]===void 0&&e[Symbol.asyncIterator]===void 0)throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof e})`);if(typeof t!="function")throw new TypeError("Mapper function is required");if(!((Number.isSafeInteger(n)||n===Number.POSITIVE_INFINITY)&&n>=1))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${n}\` (${typeof n})`);let m=[],w=[],d=new Map,S=!1,p=!1,f=!1,h=0,O=0,b=e[Symbol.iterator]===void 0?e[Symbol.asyncIterator]():e[Symbol.iterator](),y=v=>{S=!0,p=!0,l(v);};r&&(r.aborted&&y(Et(r)),r.addEventListener("abort",()=>{y(Et(r));}));let I=()=>c(this,null,function*(){if(p)return;let v=yield b.next(),R=O;if(O++,v.done){if(f=!0,h===0&&!p){if(!o&&w.length>0){y(new AggregateError(w));return}if(p=!0,d.size===0){a(m);return}let K=[];for(let[_,J]of m.entries())d.get(_)!==bt&&K.push(J);a(K);}return}h++,c(this,null,function*(){try{let K=yield v.value;if(p)return;let _=yield t(K,R);_===bt&&d.set(R,_),m[R]=_,h--,yield I();}catch(K){if(o)y(K);else {w.push(K),h--;try{yield I();}catch(_){y(_);}}}});});c(this,null,function*(){for(let v=0;v<n;v++){try{yield I();}catch(R){y(R);break}if(f||S)break}});})})}var bt=Symbol("skip");var L=({chainId:e,multiChain:t})=>{let n=u(r=>r.chains);if(!n)throw new Error("No chains found in GrazProvider");let o=typeof e=="string"?[e]:e;switch(!0){case(!!t&&!!o):return o.map(r=>n.find(i=>i.chainId===r)).filter(Boolean);case(!t&&!!o):return [o.map(r=>n.find(i=>i.chainId===r)).filter(Boolean)[0]];case(!!t&&!o):return n;default:return [n[0]]}},z=(e,t,n)=>c(void 0,null,function*(){let o=u.getState().multiChainFetchConcurrency;if(e){let i=yield Re(t,n,{concurrency:o});return Object.fromEntries(i.map((s,a)=>[t[a].chainId,s]))}return yield n(t[0])}),Tt=(e,t,n)=>{if(e){let r=t.map(n);return Object.fromEntries(r.map((i,s)=>[t[s].chainId,i]))}return n(t[0])};var Ke=e=>{let t=L({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=useMemo(()=>["USE_STARGATE_CLIENT",t],[t]);return useQuery({queryKey:n,queryFn:r=>c(void 0,[r],function*({queryKey:[,o]}){if(o.length<1)throw new Error("No chains found");return yield z(!!(e!=null&&e.multiChain),o,s=>c(void 0,null,function*(){var w;let a=(w=u.getState().chainsConfig)==null?void 0:w[s.chainId],l={url:s.rpc,headers:x({},(a==null?void 0:a.rpcHeaders)||{})};return yield StargateClient.connect(l)}))}),enabled:!!t&&t.length>0&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})},Ne=e=>{let t=L({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=useMemo(()=>["USE_COSMWASM_CLIENT",t],[t]);return useQuery({queryKey:n,queryFn:r=>c(void 0,[r],function*({queryKey:[,o]}){if(o.length<1)throw new Error("No chains found");return yield z(!!(e!=null&&e.multiChain),o,s=>c(void 0,null,function*(){var w;let a=(w=u.getState().chainsConfig)==null?void 0:w[s.chainId],l={url:s.rpc,headers:x({},(a==null?void 0:a.rpcHeaders)||{})};return yield CosmWasmClient.connect(l)}))}),enabled:!!t&&t.length>0&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})},he=({type:e,chainId:t,multiChain:n,enabled:o})=>{let r=L({chainId:t,multiChain:n}),i=useMemo(()=>["USE_TENDERMINT_CLIENT",e,r],[e,r]);return useQuery({queryKey:i,queryFn:l=>c(void 0,[l],function*({queryKey:[,s,a]}){if(a.length<1)throw new Error("No chains found");return yield z(!!n,a,w=>c(void 0,null,function*(){var h;let d=(h=u.getState().chainsConfig)==null?void 0:h[w.chainId],S={url:w.rpc,headers:x({},(d==null?void 0:d.rpcHeaders)||{})};return yield (s==="tm37"?Tendermint37Client:Tendermint34Client).connect(S)}))}),enabled:!!r&&r.length>0&&(o!==void 0?!!o:!0),refetchOnWindowFocus:!1})};var Vr=()=>u(e=>({walletType:e.walletType,isCosmostation:e.walletType==="cosmostation",isCosmostationMobile:e.walletType==="wc_cosmostation_mobile",isKeplr:e.walletType==="keplr",isKeplrMobile:e.walletType==="wc_keplr_mobile",isLeap:e.walletType==="leap",isLeapMobile:e.walletType==="wc_leap_mobile",isVectis:e.walletType==="vectis",isWalletConnect:e.walletType==="walletconnect",isMetamaskSnapLeap:e.walletType==="metamask_snap_leap",isStation:e.walletType==="station",isCapsule:e.walletType==="capsule",isCosmiframe:e.walletType==="cosmiframe"}),shallow),we=e=>{let n=["USE_CHECK_WALLET",u(r=>e||r.walletType)];return useQuery({queryKey:n,queryFn:({queryKey:[,r]})=>B(r)})};var X=e=>{let t=u(a=>a.walletType),n=g(a=>a.activeChainIds),o=L({chainId:e!=null&&e.chainId?e.chainId:n||void 0,multiChain:e==null?void 0:e.multiChain}),r=g(a=>a.accounts),i=g(a=>a.status);return useEffect(()=>g.subscribe(a=>a.status,(a,l)=>{var m,w,d;if(a==="connected"){let{accounts:S,activeChainIds:p}=g.getState(),{chains:f}=u.getState(),{walletType:h}=u.getState();if(!S||!p||!f)return (m=e==null?void 0:e.onDisconnect)==null?void 0:m.call(e);(w=e==null?void 0:e.onConnect)==null||w.call(e,{accounts:S,chains:p.map(O=>f.find(b=>b.chainId===O)),walletType:h,isReconnect:l==="reconnecting"});}a==="disconnected"&&((d=e==null?void 0:e.onDisconnect)==null||d.call(e));}),[e]),{data:useMemo(()=>r?Tt(!!(e!=null&&e.multiChain),o,a=>r[a.chainId]):void 0,[r,o,e==null?void 0:e.multiChain]),isConnected:i==="connected",isConnecting:i==="connecting",isDisconnected:i==="disconnected",isReconnecting:i==="reconnecting",isLoading:i==="connecting"||i==="reconnecting",walletType:i==="connected"?t:void 0,reconnect:G,status:i}},hn=e=>{let t=L({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),{data:n}=X(),o=(e==null?void 0:e.bech32Address)||(n==null?void 0:n.bech32Address),{data:r}=Ke({chainId:t.map(s=>s.chainId),multiChain:!0,enabled:((e==null?void 0:e.enabled)===void 0?!0:e.enabled)&&!!o}),i=useMemo(()=>["USE_ALL_BALANCES",r,t,o,e==null?void 0:e.chainId],[o,e==null?void 0:e.chainId,t,r]);return useQuery({queryKey:i,queryFn:m=>c(void 0,[m],function*({queryKey:[,s,a,l]}){if(!l)throw new Error("address is not defined");return yield z(!!(e!=null&&e.multiChain),a,d=>c(void 0,null,function*(){let S=s==null?void 0:s[d.chainId];if(!S)throw new Error(`Client is not ready ${d.chainId}`);return yield S.getAllBalances(toBech32(d.bech32Config.bech32PrefixAccAddr,fromBech32(l).data))}))}),enabled:!!o&&!!t&&t.length>0&&!Ce(r)&&((e==null?void 0:e.enabled)===void 0?!0:e.enabled),refetchOnMount:!1,refetchOnReconnect:!0,refetchOnWindowFocus:!1})},as=e=>{let t=L({chainId:e.chainId}),{data:n}=X({chainId:e.chainId}),o=e.bech32Address||(n==null?void 0:n.bech32Address),{data:r,refetch:i}=hn({chainId:t.map(l=>l.chainId),bech32Address:o,enabled:!!o&&(e.enabled===void 0?!0:e.enabled)}),s=["USE_BALANCE",e.denom,r,t,o,e.chainId],a=useQuery({queryKey:s,queryFn:({queryKey:[,l,m]})=>m==null?void 0:m.find(w=>w.denom===l),enabled:!!e.denom&&!!r&&!!(r!=null&&r.length)&&(e.enabled===void 0?!0:e.enabled)});return q(x({},a),{refetch:l=>c(void 0,null,function*(){return yield i(),a.refetch(l)})})},cs=({onError:e,onLoading:t,onSuccess:n}={})=>{let r=useMutation({mutationKey:["USE_CONNECT",e,t,n],mutationFn:Y,onError:(s,a)=>e==null?void 0:e(s,a),onMutate:t,onSuccess:s=>Promise.resolve(n==null?void 0:n(s))}),{data:i}=we();return {connect:s=>r.mutate(s),connectAsync:s=>r.mutateAsync(s),error:r.error,isLoading:r.isPending,isSuccess:r.isSuccess,isSupported:!!i,status:r.status}},ls=({onError:e,onLoading:t,onSuccess:n}={})=>{let r=useMutation({mutationKey:["USE_DISCONNECT",e,t,n],mutationFn:oe,onError:i=>Promise.resolve(e==null?void 0:e(i,void 0)),onMutate:t,onSuccess:()=>Promise.resolve(n==null?void 0:n(void 0))});return {disconnect:i=>r.mutate(i),disconnectAsync:i=>r.mutateAsync(i),error:r.error,isLoading:r.isPending,isSuccess:r.isSuccess,status:r.status}},us=e=>{let t=L({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=u(r=>r.walletType),o=useMemo(()=>["USE_OFFLINE_SIGNERS",t,n],[t,n]);return useQuery({queryKey:o,queryFn:s=>c(void 0,[s],function*({queryKey:[,r,i]}){if(r.length<1)throw new Error("No chain found");if(!B(i))throw new Error(`${i} is not available`);return yield z(!!(e!=null&&e.multiChain),r,m=>c(void 0,null,function*(){return yield ft({chainId:m.chainId,walletType:i})}))}),enabled:!!t&&t.length>0&&!!n,refetchOnWindowFocus:!1})},ps=e=>{let t=L({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),{data:n}=X(),{data:o}=Ke({chainId:t.map(s=>s.chainId),multiChain:!0}),r=(e==null?void 0:e.bech32Address)||(n==null?void 0:n.bech32Address),i=useMemo(()=>["USE_BALANCE_STAKED",o,t,r],[t,r,o]);return useQuery({queryKey:i,queryFn:m=>c(void 0,[m],function*({queryKey:[,s,a,l]}){if(!l)throw new Error("address is not defined");return yield z(!!(e!=null&&e.multiChain),a,d=>c(void 0,null,function*(){var p;if(!s)throw new Error("Client is not ready");return yield (p=s[d.chainId])==null?void 0:p.getBalanceStaked(toBech32(d.bech32Config.bech32PrefixAccAddr,fromBech32(l).data))}))}),enabled:!!r&&!!t&&t.length>0&&!!o,refetchOnMount:!1,refetchOnReconnect:!0,refetchOnWindowFocus:!1})};var Cs=()=>{let e=u(o=>o.capsuleState),t=g(o=>o.capsuleClient),n=ce();return {setModalState:o=>{u.setState(r=>{var i;return {capsuleState:{showModal:o,chainId:(i=r.capsuleState)==null?void 0:i.chainId}}});},modalState:!!(e!=null&&e.showModal),client:t,onAfterLoginSuccessful:n.onAfterLoginSuccessful,onLoginFailure:()=>{oe();}}};var bs=()=>g(e=>e.activeChainIds),wn=()=>{var e;return (e=g(t=>t.activeChainIds))==null?void 0:e.map(t=>{var o;let n=(o=u.getState().chains)==null?void 0:o.find(r=>r.chainId===t);if(n)return n}).filter(Boolean)},Ts=({chainId:e})=>{var t;return (t=u().chains)==null?void 0:t.find(n=>n.chainId===e)},Ms=({chainId:e})=>{var t;return (t=u().chains)==null?void 0:t.filter(n=>e==null?void 0:e.includes(n.chainId))},xs=({denom:e})=>{let t=wn();return useQuery({queryKey:["USE_ACTIVE_CHAIN_CURRENCY",e],queryFn:({queryKey:[,r]})=>{var i;return (i=t==null?void 0:t.find(s=>s.currencies.find(a=>a.coinMinimalDenom===r)))==null?void 0:i.currencies.find(s=>s)}})},vs=e=>{var r;let t=(r=e.status)!=null?r:"BOND_STATUS_BONDED",n=["USE_ACTIVE_CHAIN_VALIDATORS",e.queryClient,t];return useQuery({queryKey:n,queryFn:a=>c(void 0,[a],function*({queryKey:[,i,s]}){if(!i)throw new Error("Query client is not defined");return yield i.staking.validators(s)}),enabled:typeof e.queryClient!="undefined"})},ks=()=>({data:u(t=>t.recentChainIds),clear:ke}),Ps=()=>{var t;return {data:(t=u(n=>n.recentChainIds))==null?void 0:t.map(n=>{var r;let o=(r=u.getState().chains)==null?void 0:r.find(i=>i.chainId===n);if(o)return o}).filter(Boolean),clear:ke}},Ws=({onError:e,onLoading:t,onSuccess:n}={})=>{let r=useMutation({mutationKey:["USE_SUGGEST_CHAIN",e,t,n],mutationFn:Pe,onError:(i,s)=>Promise.resolve(e==null?void 0:e(i,s.chainInfo)),onMutate:i=>t==null?void 0:t(i.chainInfo),onSuccess:i=>Promise.resolve(n==null?void 0:n(i))});return {error:r.error,isLoading:r.isPending,isSuccess:r.isSuccess,suggest:r.mutate,suggestAsync:r.mutateAsync,status:r.status}},Rs=({onError:e,onLoading:t,onSuccess:n}={})=>{let r=useMutation({mutationKey:["USE_SUGGEST_CHAIN_AND_CONNECT",e,t,n],mutationFn:gt,onError:(s,a)=>Promise.resolve(e==null?void 0:e(s,a)),onMutate:s=>t==null?void 0:t(s),onSuccess:s=>Promise.resolve(n==null?void 0:n(s))}),{data:i}=we();return {error:r.error,isLoading:r.isPending,isSuccess:r.isSuccess,isSupported:!!i,status:r.status,suggestAndConnect:r.mutate,suggestAndConnectAsync:r.mutateAsync}};var Fs=({onError:e,onLoading:t,onSuccess:n}={})=>{let{data:o}=X(),r=o==null?void 0:o.bech32Address,i=useMutation({mutationKey:["USE_SEND_TOKENS",e,t,n,r],mutationFn:s=>St(x({senderAddress:r},s)),onError:(s,a)=>Promise.resolve(e==null?void 0:e(s,a)),onMutate:t,onSuccess:s=>Promise.resolve(n==null?void 0:n(s))});return {error:i.error,isLoading:i.isPending,isSuccess:i.isSuccess,sendTokens:i.mutate,sendTokensAsync:i.mutateAsync,status:i.status}},qs=({onError:e,onLoading:t,onSuccess:n}={})=>{let{data:o}=X(),r=o==null?void 0:o.bech32Address,i=useMutation({mutationKey:["USE_SEND_IBC_TOKENS",e,t,n,r],mutationFn:s=>Ct(x({senderAddress:r},s)),onError:(s,a)=>Promise.resolve(e==null?void 0:e(s,a)),onMutate:t,onSuccess:s=>Promise.resolve(n==null?void 0:n(s))});return {error:i.error,isLoading:i.isPending,isSuccess:i.isSuccess,sendIbcTokens:i.mutate,sendIbcTokensAsync:i.mutateAsync,status:i.status}},Gs=({codeId:e,onError:t,onLoading:n,onSuccess:o})=>{let{data:r}=X(),i=r==null?void 0:r.bech32Address,a=useMutation({mutationKey:["USE_INSTANTIATE_CONTRACT",t,n,o,e,i],mutationFn:l=>{var w;if(!i)throw new Error("senderAddress is undefined");let m=q(x({},l),{fee:(w=l.fee)!=null?w:"auto",senderAddress:i,codeId:e});return ht(m)},onError:(l,m)=>Promise.resolve(t==null?void 0:t(l,m)),onMutate:n,onSuccess:l=>Promise.resolve(o==null?void 0:o(l))});return {error:a.error,isLoading:a.isPending,isSuccess:a.isSuccess,instantiateContract:a.mutate,instantiateContractAsync:a.mutateAsync,status:a.status}},zs=({contractAddress:e,onError:t,onLoading:n,onSuccess:o})=>{let{data:r}=X(),i=r==null?void 0:r.bech32Address,a=useMutation({mutationKey:["USE_EXECUTE_CONTRACT",t,n,o,e,i],mutationFn:l=>{var w,d,S;if(!i)throw new Error("senderAddress is undefined");let m=q(x({},l),{fee:(w=l.fee)!=null?w:"auto",senderAddress:i,contractAddress:e,memo:(d=l.memo)!=null?d:"",funds:(S=l.funds)!=null?S:[]});return wt(m)},onError:(l,m)=>Promise.resolve(t==null?void 0:t(l,m)),onMutate:n,onSuccess:l=>Promise.resolve(o==null?void 0:o(l))});return {error:a.error,isLoading:a.isPending,isSuccess:a.isSuccess,executeContract:a.mutate,executeContractAsync:a.mutateAsync,status:a.status}},Qs=e=>{let{data:t}=Ne();return useQuery({queryKey:["USE_QUERY_SMART",e==null?void 0:e.address,e==null?void 0:e.queryMsg,t],queryFn:({queryKey:[,o]})=>{if(!(e!=null&&e.address)||!e.queryMsg)throw new Error("address or queryMsg undefined");return At(e.address,e.queryMsg,t)},enabled:!!(e!=null&&e.address)&&!!(e!=null&&e.queryMsg)&&!!t})},js=e=>{let{data:t}=Ne(),n=["USE_QUERY_RAW",e==null?void 0:e.key,e==null?void 0:e.address,t];return useQuery({queryKey:n,queryFn:({queryKey:[,r]})=>{if(!(e!=null&&e.address)||!e.key)throw new Error("address or key undefined");return It(e.address,e.key,t)},enabled:!!(e!=null&&e.address)&&!!(e!=null&&e.key)&&!!t})};function ra(e){let t=L({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=u(i=>i.walletType),o=g(i=>i.activeChainIds),r=useMemo(()=>["USE_STARGATE_SIGNING_CLIENT",t,n,e,o],[o,e,t,n]);return useQuery({queryKey:r,queryFn:a=>c(this,[a],function*({queryKey:[,i,s]}){if(i.length<1)throw new Error("No chains found");return yield z(!!(e!=null&&e.multiChain),i,m=>c(this,null,function*(){var h,O;if(!(o!=null&&o.includes(m.chainId)))return null;if(!B(s))throw new Error(`${s} is not available`);let d=yield (()=>c(this,null,function*(){switch(e==null?void 0:e.offlineSigner){case"offlineSigner":return D(s).getOfflineSigner(m.chainId);case"offlineSignerAuto":return D(s).getOfflineSignerAuto(m.chainId);case"offlineSignerOnlyAmino":return D(s).getOfflineSignerOnlyAmino(m.chainId);default:return D(s).getOfflineSignerAuto(m.chainId)}}))(),S=(h=u.getState().chainsConfig)==null?void 0:h[m.chainId],p={url:m.rpc,headers:x({},(S==null?void 0:S.rpcHeaders)||{})};return (e==null?void 0:e.multiChain)===!0&&e.opts,yield SigningStargateClient.connectWithSigner(p,d,e!=null&&e.multiChain?(O=e.opts)==null?void 0:O[m.chainId]:e==null?void 0:e.opts)}))}),enabled:!!t&&t.length>0&&!!n&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}function sa(e){let t=L({chainId:e==null?void 0:e.chainId,multiChain:e==null?void 0:e.multiChain}),n=u(i=>i.walletType),o=g(i=>i.activeChainIds),r=useMemo(()=>["USE_COSMWASM_SIGNING_CLIENT",t,n,e,o],[o,e,t,n]);return useQuery({queryKey:r,queryFn:a=>c(this,[a],function*({queryKey:[,i,s]}){if(i.length<1)throw new Error("No chains found");return yield z(!!(e!=null&&e.multiChain),i,m=>c(this,null,function*(){var O,b;if(!(o!=null&&o.includes(m.chainId)))return null;if(!B(s))throw new Error(`${s} is not available`);let d=yield (()=>c(this,null,function*(){switch(e==null?void 0:e.offlineSigner){case"offlineSigner":return D(s).getOfflineSigner(m.chainId);case"offlineSignerAuto":return D(s).getOfflineSignerAuto(m.chainId);case"offlineSignerOnlyAmino":return D(s).getOfflineSignerOnlyAmino(m.chainId);default:return D(s).getOfflineSignerAuto(m.chainId)}}))(),S=(O=u.getState().chainsConfig)==null?void 0:O[m.chainId],p={url:m.rpc,headers:x({},(S==null?void 0:S.rpcHeaders)||{})},f=S!=null&&S.gas?GasPrice.fromString(`${S.gas.price}${S.gas.denom}`):void 0;return yield SigningCosmWasmClient.connectWithSigner(p,d,x({gasPrice:f},e!=null&&e.multiChain?(b=e.opts)==null?void 0:b[m.chainId]:(e==null?void 0:e.opts)||{}))}))}),enabled:!!t&&t.length>0&&!!n&&((e==null?void 0:e.enabled)!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}function aa(e){let t=L({chainId:e.chainId,multiChain:e.multiChain}),n=u(s=>s.walletType),o=g(s=>s.activeChainIds),r=useMemo(()=>["USE_STARGATE_TM_SIGNING_CLIENT",t,n,e,o],[o,e,t,n]),{data:i}=he({type:e.type,chainId:e.chainId,multiChain:e.multiChain});return useQuery({queryKey:r,queryFn:l=>c(this,[l],function*({queryKey:[,s,a]}){if(s.length<1)throw new Error("No chains found");return yield z(!!e.multiChain,s,w=>c(this,null,function*(){var h;if(!(o!=null&&o.includes(w.chainId)))return null;if(!B(a))throw new Error(`${a} is not available`);if(!i)throw new Error("No tendermint client found");let S=yield (()=>c(this,null,function*(){switch(e.offlineSigner){case"offlineSigner":return D(a).getOfflineSigner(w.chainId);case"offlineSignerAuto":return D(a).getOfflineSignerAuto(w.chainId);case"offlineSignerOnlyAmino":return D(a).getOfflineSignerOnlyAmino(w.chainId);default:return D(a).getOfflineSignerAuto(w.chainId)}}))(),p=e.multiChain?i[w.chainId]:i;return yield SigningStargateClient.createWithSigner(p,S,e.multiChain?(h=e.opts)==null?void 0:h[w.chainId]:e.opts)}))}),enabled:!!t&&t.length>0&&!!n&&!!i&&(e.enabled!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}function ca(e){let t=L({chainId:e.chainId,multiChain:e.multiChain}),n=u(a=>a.walletType),o=g(a=>a.activeChainIds),r=useMemo(()=>["USE_COSMWASM_TM_SIGNING_CLIENT",t,n,e,o],[o,e,t,n]),{data:i}=he({type:e.type,chainId:e.chainId,multiChain:!1,enabled:!e.multiChain}),{data:s}=he({type:e.type,chainId:e.chainId,multiChain:!0,enabled:!!e.multiChain});return useQuery({queryKey:r,queryFn:m=>c(this,[m],function*({queryKey:[,a,l]}){if(a.length<1)throw new Error("No chains found");return yield z(!!e.multiChain,a,d=>c(this,null,function*(){var y,I;if(!(o!=null&&o.includes(d.chainId)))return null;if(!B(l))throw new Error(`${l} is not available`);let p=yield (()=>c(this,null,function*(){switch(e.offlineSigner){case"offlineSigner":return D(l).getOfflineSigner(d.chainId);case"offlineSignerAuto":return D(l).getOfflineSignerAuto(d.chainId);case"offlineSignerOnlyAmino":return D(l).getOfflineSignerOnlyAmino(d.chainId);default:return D(l).getOfflineSignerAuto(d.chainId)}}))(),f=(y=u.getState().chainsConfig)==null?void 0:y[d.chainId],h=f!=null&&f.gas?GasPrice.fromString(`${f.gas.price}${f.gas.denom}`):void 0,O=e.multiChain?s==null?void 0:s[d.chainId]:i;if(!O)throw new Error("No tendermint client found");return yield SigningCosmWasmClient.createWithSigner(O,p,x({gasPrice:h},e.multiChain?(I=e.opts)==null?void 0:I[d.chainId]:e.opts||{}))}))}),enabled:!!t&&t.length>0&&!!n&&(!!i||!Ce(s))&&(e.enabled!==void 0?!!e.enabled:!0),refetchOnWindowFocus:!1})}var Kt=({children:e})=>{let[t,n]=useState(!1);return useEffect(()=>{n(!0);},[]),jsx(Fragment,{children:t?e:null})};var Tn=()=>{let e=typeof window!="undefined"&&window.sessionStorage.getItem(H)==="Active",{_reconnect:t,_onReconnectFailed:n,_reconnectConnector:o,iframeOptions:r,chains:i}=u(),{activeChainIds:s,wcSignClients:a}=g(),l=B(o||void 0);return useEffect(()=>{if(!r||r.autoConnect===!1||!r.allowedIframeParentOrigins.length||!i)return;new Cosmiframe(r.allowedIframeParentOrigins).isReady().then(w=>{if(w)return Y({chainId:i.map(d=>d.chainId),walletType:"cosmiframe"})});},[r]),useEffect(()=>{if(o){if(!l)return;e&&s?G({onError:n}):!e&&t&&G({onError:n});}},[l]),useEffect(()=>{var m,w,d,S,p,f,h,O,b,y,I,v,R,K,_,J,ie,C;if(o){if(!l)return;o==="cosmostation"&&((w=(m=pe()).subscription)==null||w.call(m,()=>{G({onError:n});})),o==="keplr"&&((S=(d=me()).subscription)==null||S.call(d,()=>{G({onError:n});})),o==="leap"&&((f=(p=de()).subscription)==null||f.call(p,()=>{G({onError:n});})),o==="compass"&&((O=(h=le()).subscription)==null||O.call(h,()=>{G({onError:n});})),o==="vectis"&&((y=(b=ye()).subscription)==null||y.call(b,()=>{G({onError:n});})),o==="walletconnect"&&a.has("walletconnect")&&((v=(I=j()).subscription)==null||v.call(I,()=>{G({onError:n});})),o==="station"&&((K=(R=ge()).subscription)==null||K.call(R,()=>{G({onError:n});})),o==="xdefi"&&((J=(_=Se()).subscription)==null||J.call(_,()=>{G({onError:n});})),o==="cosmiframe"&&((C=(ie=ue()).subscription)==null||C.call(ie,()=>{G({onError:n});}));}},[o,a,l]),null},Nt=()=>(Tn(),null);var vn=new QueryClient({}),Na=o=>{var r=o,{children:e,grazOptions:t}=r,n=je(r,["children","grazOptions"]);return yt(t),jsxs(QueryClientProvider,q(x({client:vn},n),{children:[e,jsx(Kt,{children:jsx(Nt,{})})]}),"graz-provider")};

export { Nt as GrazEvents, Na as GrazProvider, Ve as WALLET_TYPES, $e as WalletType, B as checkWallet, ke as clearRecentChain, N as clearSession, yt as configureGraz, Y as connect, Ar as defineChainInfo, wr as defineChains, oe as disconnect, wt as executeContract, Ho as getAvailableWallets, lr as getChainInfo, ur as getChainInfos, pe as getCosmostation, me as getKeplr, de as getLeap, st as getMetamaskSnapLeap, ft as getOfflineSigners, It as getQueryRaw, At as getQuerySmart, ar as getRecentChainIds, cr as getRecentChains, ye as getVectis, ut as getWCCosmostation, pt as getWCKeplr, mt as getWCLeap, D as getWallet, j as getWalletConnect, ht as instantiateContract, ve as isCapsule, dt as isWalletConnect, G as reconnect, Ct as sendIbcTokens, St as sendTokens, Pe as suggestChain, gt as suggestChainAndConnect, X as useAccount, xs as useActiveChainCurrency, bs as useActiveChainIds, wn as useActiveChains, Vr as useActiveWalletType, as as useBalance, ps as useBalanceStaked, hn as useBalances, Cs as useCapsule, Ts as useChainInfo, Ms as useChainInfos, we as useCheckWallet, cs as useConnect, Ne as useCosmWasmClient, sa as useCosmWasmSigningClient, ca as useCosmWasmTmSigningClient, ls as useDisconnect, zs as useExecuteContract, Tn as useGrazEvents, Gs as useInstantiateContract, us as useOfflineSigners, vs as useQueryClientValidators, js as useQueryRaw, Qs as useQuerySmart, ks as useRecentChainIds, Ps as useRecentChains, qs as useSendIbcTokens, Fs as useSendTokens, Ke as useStargateClient, ra as useStargateSigningClient, aa as useStargateTmSigningClient, Ws as useSuggestChain, Rs as useSuggestChainAndConnect, he as useTendermintClient };
